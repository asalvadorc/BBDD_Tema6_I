{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Bases de Dades","title":"Bases de Dades"},{"location":"#bases-de-dades","text":"","title":"Bases de Dades"},{"location":"BD_PostgreSQL_DQL/10_la_clusula_limit__offset/","text":"10. La cl\u00e0usula LIMIT .. OFFSET Per mig de la cl\u00e0usula LIMIT - OFFSET podrem fer que no apareguen totes les files que torna la sent\u00e8ncia, sin\u00f3 unes quantes. LIMIT n\u00famero : especificarem quantes files volem que es tornen OFFSET n\u00famero : especificarem a partir de quina posici\u00f3 volem que es tornen les files Si no posem la part del OFFSET, apareixeran les primeres, i si especifiquem OFFSET, se saltaran les primeres, tantes com s'indica en OFFSET. Per a que realment tinga sentit aquesta cl\u00e0usula, \u00e9s conveninet ordenar la informaci\u00f3, ja que al dir les primeres ja s'est\u00e0 assumint que seran les primeres respecte algun ordre. Aix\u00ed, per exemple ens podrem plantejar traure coses com les 10 poblacions m\u00e9s altes, o les m\u00e9s habitades. L'ordre impl\u00edcit que acabem de comentar s'haur\u00e0 de fer per mig de la cl\u00e0usula ORDER BY. Aix\u00ed, si volem traure els clients m\u00e9s joves haurem d'ordenar per la data de naixement en ordre descendent, per a despr\u00e9s traure els primenrs. Per tant \u00e9s molt dif\u00edcil veure una cl\u00e0usula LIMIT si no tenim una cl\u00e0usula ORDER BY. Nota En el SQL d'Access no existeix la cl\u00e0usula LIMIT. Per a fer coses similar disposa del predicat TOP , que es posa immediatament despr\u00e9s del SELECT, per\u00f2 sempre traur\u00e0 les primeres, no t\u00e9 possibilitat d'OFFSET. Sintaxi SELECT <columnes> FROM <taules> [LIMIT _n_] [OFFSET _m_] El n\u00famero n ha de ser un enter, i se seleccionaran \u00fanicament les n primeres files (les de dalt). En cas de posat OFFSET se saltaran m files. En cas de no posar LIMIT , se saltaran _ m _files i es trauran totes les altres fins el final. Per exemple, si volem traure les 10 poblacions m\u00e9s altes, haurem d'agafar les 10 primeres, ordenant per altura en forma descendent: SELECT nom , altura FROM POBLACIONS ORDER BY altura DESC LIMIT 10 L'exemple anterior sembla correcte, per\u00f2 no funciona del tot b\u00e9 perqu\u00e8 amb les dades que tenim, hi ha 3 poblacions que no tenen altura, i el valor nul el posa al final de tots els altres valors, en ordre ascendent, i per tant al principi en ordre descendent. Ho podem arreglar senzillament saltant les 3 primeres (que s\u00f3n les del nul) SELECT nom , altura FROM POBLACIONS ORDER BY altura DESC LIMIT 10 OFFSET 3 Encara que sembla millor llevar les d'altura nula, aix\u00ed no estem obligats a saber quantes poblacions amb altura nula hi ha SELECT nom , altura FROM POBLACIONS WHERE altura IS NOT NULL ORDER BY altura DESC LIMIT 10 Si vulgu\u00e9rem traure totes les poblacions i altures, excepte les que tenen nul, i sabem que aquestes en s\u00f3n 3, podem posar OFFSET sense LIMIT, per a saltar les 3 primeres, i traure-les totes fins el final SELECT nom , altura FROM POBLACIONS ORDER BY altura DESC OFFSET 3 Exemples 1) Traure les 5 poblacions m\u00e9s poblades SELECT nom , poblacio FROM POBLACIONS ORDER BY poblacio DESC LIMIT 5 2) Traure les 4 comarques amb m\u00e9s pobles. SELECT nom_c , COUNT(*) FROM POBLACIONS GROUP BY nom_c ORDER BY 2 DESC LIMIT 4 3) Traure les 10 poblacions amb m\u00e9s instituts, saltant-nos les 3 primeres. SELECT cod_m , COUNT(*) FROM INSTITUTS GROUP BY cod_m ORDER BY 2 DESC LIMIT 10 OFFSET 3 Exercicis Ex_44 Traure tota la informaci\u00f3 dels dos articles m\u00e9s cars. Ex_45 Traure el codi de les tres ciutats amb m\u00e9s clients Ex_46 Traure el venedor que ha venut menys factures Ex_47 Traure les tres factures m\u00e9s cares (sense comptar els descomptes) Ex_48 Modificar l'anterior per a traure totes les factures, excepte les 3 m\u00e9s cares. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"10. La cl\u00e0usula LIMIT .. OFFSET"},{"location":"BD_PostgreSQL_DQL/10_la_clusula_limit__offset/#10-la-clausula-limit-offset","text":"Per mig de la cl\u00e0usula LIMIT - OFFSET podrem fer que no apareguen totes les files que torna la sent\u00e8ncia, sin\u00f3 unes quantes. LIMIT n\u00famero : especificarem quantes files volem que es tornen OFFSET n\u00famero : especificarem a partir de quina posici\u00f3 volem que es tornen les files Si no posem la part del OFFSET, apareixeran les primeres, i si especifiquem OFFSET, se saltaran les primeres, tantes com s'indica en OFFSET. Per a que realment tinga sentit aquesta cl\u00e0usula, \u00e9s conveninet ordenar la informaci\u00f3, ja que al dir les primeres ja s'est\u00e0 assumint que seran les primeres respecte algun ordre. Aix\u00ed, per exemple ens podrem plantejar traure coses com les 10 poblacions m\u00e9s altes, o les m\u00e9s habitades. L'ordre impl\u00edcit que acabem de comentar s'haur\u00e0 de fer per mig de la cl\u00e0usula ORDER BY. Aix\u00ed, si volem traure els clients m\u00e9s joves haurem d'ordenar per la data de naixement en ordre descendent, per a despr\u00e9s traure els primenrs. Per tant \u00e9s molt dif\u00edcil veure una cl\u00e0usula LIMIT si no tenim una cl\u00e0usula ORDER BY. Nota En el SQL d'Access no existeix la cl\u00e0usula LIMIT. Per a fer coses similar disposa del predicat TOP , que es posa immediatament despr\u00e9s del SELECT, per\u00f2 sempre traur\u00e0 les primeres, no t\u00e9 possibilitat d'OFFSET. Sintaxi SELECT <columnes> FROM <taules> [LIMIT _n_] [OFFSET _m_] El n\u00famero n ha de ser un enter, i se seleccionaran \u00fanicament les n primeres files (les de dalt). En cas de posat OFFSET se saltaran m files. En cas de no posar LIMIT , se saltaran _ m _files i es trauran totes les altres fins el final. Per exemple, si volem traure les 10 poblacions m\u00e9s altes, haurem d'agafar les 10 primeres, ordenant per altura en forma descendent: SELECT nom , altura FROM POBLACIONS ORDER BY altura DESC LIMIT 10 L'exemple anterior sembla correcte, per\u00f2 no funciona del tot b\u00e9 perqu\u00e8 amb les dades que tenim, hi ha 3 poblacions que no tenen altura, i el valor nul el posa al final de tots els altres valors, en ordre ascendent, i per tant al principi en ordre descendent. Ho podem arreglar senzillament saltant les 3 primeres (que s\u00f3n les del nul) SELECT nom , altura FROM POBLACIONS ORDER BY altura DESC LIMIT 10 OFFSET 3 Encara que sembla millor llevar les d'altura nula, aix\u00ed no estem obligats a saber quantes poblacions amb altura nula hi ha SELECT nom , altura FROM POBLACIONS WHERE altura IS NOT NULL ORDER BY altura DESC LIMIT 10 Si vulgu\u00e9rem traure totes les poblacions i altures, excepte les que tenen nul, i sabem que aquestes en s\u00f3n 3, podem posar OFFSET sense LIMIT, per a saltar les 3 primeres, i traure-les totes fins el final SELECT nom , altura FROM POBLACIONS ORDER BY altura DESC OFFSET 3 Exemples 1) Traure les 5 poblacions m\u00e9s poblades SELECT nom , poblacio FROM POBLACIONS ORDER BY poblacio DESC LIMIT 5 2) Traure les 4 comarques amb m\u00e9s pobles. SELECT nom_c , COUNT(*) FROM POBLACIONS GROUP BY nom_c ORDER BY 2 DESC LIMIT 4 3) Traure les 10 poblacions amb m\u00e9s instituts, saltant-nos les 3 primeres. SELECT cod_m , COUNT(*) FROM INSTITUTS GROUP BY cod_m ORDER BY 2 DESC LIMIT 10 OFFSET 3","title":"10. La cl\u00e0usula LIMIT .. OFFSET"},{"location":"BD_PostgreSQL_DQL/10_la_clusula_limit__offset/#exercicis","text":"Ex_44 Traure tota la informaci\u00f3 dels dos articles m\u00e9s cars. Ex_45 Traure el codi de les tres ciutats amb m\u00e9s clients Ex_46 Traure el venedor que ha venut menys factures Ex_47 Traure les tres factures m\u00e9s cares (sense comptar els descomptes) Ex_48 Modificar l'anterior per a traure totes les factures, excepte les 3 m\u00e9s cares. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/11_consulta_de_creaci_de_taules/","text":"11. Consulta de creaci\u00f3 de taules A banda de poder consultar informaci\u00f3 de una o m\u00e9s d'una taula, la sent\u00e8ncia SELECT pot servir per a crear una nova taula, amb estructura i dades (les que venen de la pr\u00f2pia sent\u00e8ncia SELECT). Aix\u00f2 s\u00ed, no podrem definir d'aquesta manera ni clau principal, ni claus externes, ni cap altra restricci\u00f3 de les conegudes. A m\u00e9s, aquesta caracter\u00edstica escapa del est\u00e0ndard ANSI SQL, per la qual cosa no li donarem excessiva import\u00e0ncia. Sintaxi SELECT <columnes> INTO nova_taula FROM <taules> La sent\u00e8ncia pot dur qualsevol cl\u00e0usula o predicat dels vistos fins ara, i el resultat que done aquesta sent\u00e8ncia, es guardar\u00e0 en una nova taula, amb el nom especificat. El nom dels camps de la nova taula seran els especificats en l'apartat . Per tant \u00e9s especialment recomanable la utilitzaci\u00f3 d'\u00e0lies, ja que si en posem seran el noms dels camps de la nova taula. Els tipus de dades dels camps seran els heretats de la consulta SELECT. En cas d'existir ja una taula amb el nom especificat ens avisar\u00e0 d'aquest fet, donant-nos la possibilitat d'esborrar la taula anterior i crear la nova o cancelar. Nota \u00c9s molt recomanable, com d'altres sent\u00e8ncies de manipulaci\u00f3 de dades que veurem m\u00e9s endavant, executar primer la sent\u00e8ncia sense el INTO , per a no crear la taula encara. Quan estiguem segurs que el resultat \u00e9s el que desitgem, afegim el INTO, i la taula es crear\u00e0 a m\u00e9s garanties. Exemples 1) Crear una c\u00f2pia de la taula comarques anomenada COMARQUES_COPIA . SELECT * INTO COMARQUES_COPIA FROM COMARQUES Per a no \"embrutar\" la Base de Dades, podem esborrar-la despr\u00e9s d'haver vist la seua creaci\u00f3 amb la sent\u00e8ncia DROP TABLE COMARQUES_COPIA 2) Crear una taula anomenada RESUM_COMARQUES que continga el nom de la comarca, el n\u00famero de pobles, el total de poblaci\u00f3 i l'altura mitjana SELECT nom_c, COUNT(*) AS num_pobles, SUM(poblacio) AS poblacio , SUM(extensio) AS extensio , AVG(altura) AS altura_mitjana INTO RESUM_COMARQUES FROM POBLACIONS GROUP BY nom_c Igual que en l'anterior, despr\u00e9s d'haver vist la seua creaci\u00f3 i contingut, podem esborrar-la amb la sent\u00e8ncia DROP TABLE RESUM_COMARQUES Exercicis Ex_49 Crear una taula anomenada ARTICLE_999x , on 999 han de ser les 3 \u00faltimes xifres del DNI, i x la lletra del teu NIF, que siga una c\u00f2pia de la taula ARTICLE, per\u00f2 substituint els valors nuls de stock i stock_min per zeros. Ex_50 Utilitzar la taula anterior per a traure el stock m\u00e0xim, el m\u00ednim i la mitjana de stocks. Observeu que si utilitz\u00e0rem la taula ARTICLE, els resultats no serien els mateixos (excepte el m\u00e0xim), sobretot la mitjana, ja que els valors nuls no entrarien en els c\u00e0lculs d'aquesta mitjana. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"11. Consulta de creaci\u00f3 de taules"},{"location":"BD_PostgreSQL_DQL/11_consulta_de_creaci_de_taules/#11-consulta-de-creacio-de-taules","text":"A banda de poder consultar informaci\u00f3 de una o m\u00e9s d'una taula, la sent\u00e8ncia SELECT pot servir per a crear una nova taula, amb estructura i dades (les que venen de la pr\u00f2pia sent\u00e8ncia SELECT). Aix\u00f2 s\u00ed, no podrem definir d'aquesta manera ni clau principal, ni claus externes, ni cap altra restricci\u00f3 de les conegudes. A m\u00e9s, aquesta caracter\u00edstica escapa del est\u00e0ndard ANSI SQL, per la qual cosa no li donarem excessiva import\u00e0ncia. Sintaxi SELECT <columnes> INTO nova_taula FROM <taules> La sent\u00e8ncia pot dur qualsevol cl\u00e0usula o predicat dels vistos fins ara, i el resultat que done aquesta sent\u00e8ncia, es guardar\u00e0 en una nova taula, amb el nom especificat. El nom dels camps de la nova taula seran els especificats en l'apartat . Per tant \u00e9s especialment recomanable la utilitzaci\u00f3 d'\u00e0lies, ja que si en posem seran el noms dels camps de la nova taula. Els tipus de dades dels camps seran els heretats de la consulta SELECT. En cas d'existir ja una taula amb el nom especificat ens avisar\u00e0 d'aquest fet, donant-nos la possibilitat d'esborrar la taula anterior i crear la nova o cancelar. Nota \u00c9s molt recomanable, com d'altres sent\u00e8ncies de manipulaci\u00f3 de dades que veurem m\u00e9s endavant, executar primer la sent\u00e8ncia sense el INTO , per a no crear la taula encara. Quan estiguem segurs que el resultat \u00e9s el que desitgem, afegim el INTO, i la taula es crear\u00e0 a m\u00e9s garanties. Exemples 1) Crear una c\u00f2pia de la taula comarques anomenada COMARQUES_COPIA . SELECT * INTO COMARQUES_COPIA FROM COMARQUES Per a no \"embrutar\" la Base de Dades, podem esborrar-la despr\u00e9s d'haver vist la seua creaci\u00f3 amb la sent\u00e8ncia DROP TABLE COMARQUES_COPIA 2) Crear una taula anomenada RESUM_COMARQUES que continga el nom de la comarca, el n\u00famero de pobles, el total de poblaci\u00f3 i l'altura mitjana SELECT nom_c, COUNT(*) AS num_pobles, SUM(poblacio) AS poblacio , SUM(extensio) AS extensio , AVG(altura) AS altura_mitjana INTO RESUM_COMARQUES FROM POBLACIONS GROUP BY nom_c Igual que en l'anterior, despr\u00e9s d'haver vist la seua creaci\u00f3 i contingut, podem esborrar-la amb la sent\u00e8ncia DROP TABLE RESUM_COMARQUES","title":"11. Consulta de creaci\u00f3 de taules"},{"location":"BD_PostgreSQL_DQL/11_consulta_de_creaci_de_taules/#exercicis","text":"Ex_49 Crear una taula anomenada ARTICLE_999x , on 999 han de ser les 3 \u00faltimes xifres del DNI, i x la lletra del teu NIF, que siga una c\u00f2pia de la taula ARTICLE, per\u00f2 substituint els valors nuls de stock i stock_min per zeros. Ex_50 Utilitzar la taula anterior per a traure el stock m\u00e0xim, el m\u00ednim i la mitjana de stocks. Observeu que si utilitz\u00e0rem la taula ARTICLE, els resultats no serien els mateixos (excepte el m\u00e0xim), sobretot la mitjana, ja que els valors nuls no entrarien en els c\u00e0lculs d'aquesta mitjana. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/12_ordre_amb_qu_sexecuta_una_sentncia_sql/","text":"12. Ordre amb qu\u00e8 s'executa una sent\u00e8ncia SQL Com hem vist, i com veurem en la Part II d'aquest tema, la sent\u00e8ncia SELECT \u00e9s molt completa i molt potent. Pot fer moltes coses. Potser ens convinga saber en quin ordre s'executen les cl\u00e0usules de qu\u00e8 es compon, perqu\u00e8 aix\u00f2 ens pot prevenir de possibles errors en el moment de construir una sent\u00e8ncia d'una certa envergadura. L'ordre d'execuci\u00f3 \u00e9s el seg\u00fcent: Primer s'agafen les dades des de la taula o les taules especificades en el FROM . No podrem tractar informaci\u00f3 que no tinguem en aquest origen de dades. Despr\u00e9s s'eliminen les files que no acompleixen la condici\u00f3 del WHERE , en cas que tinguem aquesta cl\u00e0usula. Despr\u00e9s les files resultants s'agrupen pel o pels camps especificats en el GROUP BY , en cas que tinguem aquesta cl\u00e0usula. Una vegada fets els grups, s'eliminen els que no acomplesquen la condici\u00f3 del HAVING , en cas que tinguem aquesta cl\u00e0usula. Despr\u00e9s se selecciona la informaci\u00f3 especificada en les columnes, que en cas d'haver alguna funci\u00f3 d'agregat actuar\u00e0 sobre els grups que resten (si ten\u00edem cl\u00e0usula GROUP BY) o sobre el total de l'origen de dades. Posteriorment s'ordena pels camps especificats en el ORDER BY , en cas que tinguem aquesta cl\u00e0usula. Despr\u00e9s s'aplica els predicat DISTINCT en cas de tenir-lo especificat. Per \u00faltim s'agafen tantes files com indica la cl\u00e0usula LIMIT , despla\u00e7ades tantes com indique OFFSET , si \u00e9s que tenim aquesta cl\u00e0usula especificada.. Si tenim cl\u00e0usula INTO es procedir\u00e0 a crear una taula nova amb el resultat anterior. Tenir clar aquest ordre ens pot clarificar alguna cosa, i poder evitar alguns errors. L'error de la seg\u00fcent sent\u00e8ncia ja s'havia explicat en l'apartat de la cl\u00e0usula GROUP BY. SELECT nom_c, COUNT(*), cod_m FROM POBLACIONS GROUP BY nom_c ens donar\u00e0 el seg\u00fcent error: Per\u00f2 si analitzem l'ordre en qu\u00e8 s'executen \u00e9s l\u00f2gic: quan arribem a mostrar els camps (entre ells cod_m ) els grups ja s'han fet, i per a valors iguals de nom_c . En aquest moment no puc traure una cosa individual de cada grup com \u00e9s el codi de municipi, perqu\u00e8 ja s'ha agrupat. En aquest moment nom\u00e9s es pot intentar traure el nom de la comarca (ja que t\u00e9 el mateix valor per a tot el grup, \u00e9s el camp pel qual hem agrupat), o alguna funci\u00f3 d'agregat, que calcula sobre el grup. I d'aix\u00f2 ens intenta avisar PostgreSQL. Per a solucionar-lo podem incloure el cod_m en el GROUP BY , i aleshores farem un grup per cada comarca i poblaci\u00f3 diferent, per\u00f2 segurament aix\u00f2 no ens valdr\u00e0 de res en aquest exemple, perqu\u00e8 cada grup nom\u00e9s contindr\u00e0 un element (un municipi), encara que en altres exemples s\u00ed que pot tenir sentit. O si no era aix\u00f2 el que preten\u00edem, senzillament llevem el camp cod_m de la sent\u00e8ncia, i ens funcionar\u00e0 b\u00e9. Un altre exemple il\u00b7lustratiu (que ja el vam posar molt paregut en l'apartat de la cl\u00e0usula GROUP BY) pot ser el seg\u00fcent: podr\u00edem intentar traure l'altura m\u00e0xima de tots els pobles, i la poblaci\u00f3 que t\u00e9 aquesta altura. Podr\u00edem estar temptats de fer-lo d'aquesta manera: SELECT MAX(altura), nom FROM POBLACIONS; Ens donar\u00e0 el mateix error que abans, ja que com tenim una funci\u00f3 d'agregat intentar\u00e0 fer grups, i com no tenim cl\u00e0usula GROUP BY tota la taula ser\u00e0 un grup. I podr\u00e0 calcular el m\u00e0xim sense problemes, per\u00f2 no podr\u00e0 traure una cosa individual del grup, com \u00e9s el nom. I en aquest cas no es pot solucionar incloent el nom en el GROUP BY, perqu\u00e8 aleshores farem un grup per cada poblaci\u00f3. De moment, abans de veure les subconsultes, nom\u00e9s podem resoldre aquest exemple ordenant per l'altura de forma descendent, i fer LIMIT 1 . Podem observar que si tenim cl\u00e0usula GROUP BY , a partir d'aquest moment tots els camps que posem han d'estar en el GROUP BY o en una funci\u00f3 d'agregat, tant en la condici\u00f3 del HAVING , com en les columnes com en el ORDER BY . En canvi no caldr\u00e0 per a la cl\u00e0usula WHERE , ja que aquesta es realitza abans que el GROUP BY Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"12. Ordre amb que s'executa una sent\u00e8ncia SQL"},{"location":"BD_PostgreSQL_DQL/12_ordre_amb_qu_sexecuta_una_sentncia_sql/#12-ordre-amb-que-sexecuta-una-sentencia-sql","text":"Com hem vist, i com veurem en la Part II d'aquest tema, la sent\u00e8ncia SELECT \u00e9s molt completa i molt potent. Pot fer moltes coses. Potser ens convinga saber en quin ordre s'executen les cl\u00e0usules de qu\u00e8 es compon, perqu\u00e8 aix\u00f2 ens pot prevenir de possibles errors en el moment de construir una sent\u00e8ncia d'una certa envergadura. L'ordre d'execuci\u00f3 \u00e9s el seg\u00fcent: Primer s'agafen les dades des de la taula o les taules especificades en el FROM . No podrem tractar informaci\u00f3 que no tinguem en aquest origen de dades. Despr\u00e9s s'eliminen les files que no acompleixen la condici\u00f3 del WHERE , en cas que tinguem aquesta cl\u00e0usula. Despr\u00e9s les files resultants s'agrupen pel o pels camps especificats en el GROUP BY , en cas que tinguem aquesta cl\u00e0usula. Una vegada fets els grups, s'eliminen els que no acomplesquen la condici\u00f3 del HAVING , en cas que tinguem aquesta cl\u00e0usula. Despr\u00e9s se selecciona la informaci\u00f3 especificada en les columnes, que en cas d'haver alguna funci\u00f3 d'agregat actuar\u00e0 sobre els grups que resten (si ten\u00edem cl\u00e0usula GROUP BY) o sobre el total de l'origen de dades. Posteriorment s'ordena pels camps especificats en el ORDER BY , en cas que tinguem aquesta cl\u00e0usula. Despr\u00e9s s'aplica els predicat DISTINCT en cas de tenir-lo especificat. Per \u00faltim s'agafen tantes files com indica la cl\u00e0usula LIMIT , despla\u00e7ades tantes com indique OFFSET , si \u00e9s que tenim aquesta cl\u00e0usula especificada.. Si tenim cl\u00e0usula INTO es procedir\u00e0 a crear una taula nova amb el resultat anterior. Tenir clar aquest ordre ens pot clarificar alguna cosa, i poder evitar alguns errors. L'error de la seg\u00fcent sent\u00e8ncia ja s'havia explicat en l'apartat de la cl\u00e0usula GROUP BY. SELECT nom_c, COUNT(*), cod_m FROM POBLACIONS GROUP BY nom_c ens donar\u00e0 el seg\u00fcent error: Per\u00f2 si analitzem l'ordre en qu\u00e8 s'executen \u00e9s l\u00f2gic: quan arribem a mostrar els camps (entre ells cod_m ) els grups ja s'han fet, i per a valors iguals de nom_c . En aquest moment no puc traure una cosa individual de cada grup com \u00e9s el codi de municipi, perqu\u00e8 ja s'ha agrupat. En aquest moment nom\u00e9s es pot intentar traure el nom de la comarca (ja que t\u00e9 el mateix valor per a tot el grup, \u00e9s el camp pel qual hem agrupat), o alguna funci\u00f3 d'agregat, que calcula sobre el grup. I d'aix\u00f2 ens intenta avisar PostgreSQL. Per a solucionar-lo podem incloure el cod_m en el GROUP BY , i aleshores farem un grup per cada comarca i poblaci\u00f3 diferent, per\u00f2 segurament aix\u00f2 no ens valdr\u00e0 de res en aquest exemple, perqu\u00e8 cada grup nom\u00e9s contindr\u00e0 un element (un municipi), encara que en altres exemples s\u00ed que pot tenir sentit. O si no era aix\u00f2 el que preten\u00edem, senzillament llevem el camp cod_m de la sent\u00e8ncia, i ens funcionar\u00e0 b\u00e9. Un altre exemple il\u00b7lustratiu (que ja el vam posar molt paregut en l'apartat de la cl\u00e0usula GROUP BY) pot ser el seg\u00fcent: podr\u00edem intentar traure l'altura m\u00e0xima de tots els pobles, i la poblaci\u00f3 que t\u00e9 aquesta altura. Podr\u00edem estar temptats de fer-lo d'aquesta manera: SELECT MAX(altura), nom FROM POBLACIONS; Ens donar\u00e0 el mateix error que abans, ja que com tenim una funci\u00f3 d'agregat intentar\u00e0 fer grups, i com no tenim cl\u00e0usula GROUP BY tota la taula ser\u00e0 un grup. I podr\u00e0 calcular el m\u00e0xim sense problemes, per\u00f2 no podr\u00e0 traure una cosa individual del grup, com \u00e9s el nom. I en aquest cas no es pot solucionar incloent el nom en el GROUP BY, perqu\u00e8 aleshores farem un grup per cada poblaci\u00f3. De moment, abans de veure les subconsultes, nom\u00e9s podem resoldre aquest exemple ordenant per l'altura de forma descendent, i fer LIMIT 1 . Podem observar que si tenim cl\u00e0usula GROUP BY , a partir d'aquest moment tots els camps que posem han d'estar en el GROUP BY o en una funci\u00f3 d'agregat, tant en la condici\u00f3 del HAVING , com en les columnes com en el ORDER BY . En canvi no caldr\u00e0 per a la cl\u00e0usula WHERE , ja que aquesta es realitza abans que el GROUP BY Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"12. Ordre amb qu\u00e8 s'executa una sent\u00e8ncia SQL"},{"location":"BD_PostgreSQL_DQL/1_introducci/","text":"1. Introducci\u00f3 SQL \u00e9s un llenguatge per a organitzar, gestionar i recuperar dades emmagatzemades en una Base de Dades. El nom \" SQL \" \u00e9s una abreviatura de Structured Query Language (Llenguatge Estructurat de Consultes), i com el seu nom indica, \u00e9s un llenguatge inform\u00e0tic que es pot utilitzar per a interaccions amb una Base de Dades de tipus relacional. SQL s'utilitza per a controlar totes les funcions que un SGBD proporciona als seus usuaris, incloent: Definici\u00f3 de dades . SQL permet a un usuari definir l'estructura i organitzaci\u00f3 de les dades emmagatzemades i les relacions existents entre elles (claus externes). Recuperaci\u00f3 de dades . SQL permet a un usuari o a un programa d'aplicaci\u00f3 recuperar les dades emmagatzemades de la base de dades i utilitzar-les. Manipulaci\u00f3 de dades . SQL permet a un usuari o a un programa d'aplicaci\u00f3 actualitzar la base de dades afegint noves dades, suprimint dades antigues i modificant dades pr\u00e8viament emmagatzemades. Control d'acc\u00e9s . SQL pot ser utilitzat per a restringir la capacitat d'un usuari per a recuperar, afegir i modificar dades, protegint aix\u00ed les dades guardades davant d'accessos no autoritzats. Compartici\u00f3 de dades . SQL s'utilitza per a coordinar la compartici\u00f3 de dades per part d'usuaris concurrents, assegurant que no interfereixen entre ells. Integritat de dades . SQL defineix restriccions d'integritat en la base de dades, protegint-la contra corrupcions causades per actualitzacions inconsistents o per fallades del sistema. SQL no \u00e9s realment un llenguatge inform\u00e0tic complet tal com JAVA, C o Python. SQL no disposa de la sent\u00e8ncia IF per a examinar condicions, ni de les sent\u00e8ncies WHILE o FOR per a fer bucles, per exemple. En compte d'aix\u00f2, SQL \u00e9s un subllenguatge de base de dades, que consta d'unes trenta sent\u00e8ncies especialitzades per a tasques de gesti\u00f3 de bases de dades, per\u00f2 nom\u00e9s 7 s\u00f3n les sent\u00e8ncies principals . Tamb\u00e9 es diu que \u00e9s un llenguatge de quarta generaci\u00f3 perqu\u00e8 en ell es diu quina informaci\u00f3 es vol, sense especificar exactament com s'aconsegueix aquesta informaci\u00f3. Tamb\u00e9 es diu que \u00e9s un llenguatge orientat a conjunt de registres , ja que una sent\u00e8ncia pot tornar un conjunt de registres. A\u00e7\u00f2 \u00e9s un gran avantatge amb els llenguatges de tercera generaci\u00f3, que nom\u00e9s podien treballar registre a registre. Dues s\u00f3n les maneres d'executar sent\u00e8ncies SQL. De forma interactiva : s'escriu una sent\u00e8ncia SQL, i s'executa, tornant normalment un conjunt de registres que es presentaran en forma tabular. En Access el lloc on procedir d'aquesta manera \u00e9s en les consultes , triant Vista SQL . Tindrem lloc per escriure la sent\u00e8ncia tal i com es mostra en la primera imatge. En la segona imatge, es mostra una consulta ja feta en el tema anterior, per\u00f2 veient-la en SQL. En la tercera hem executat la consulta: Dins d'un programa escrit en un altre llenguatge, que actuar\u00e0 com llenguatge amfitri\u00f3 (i el SQL seria el llenguatge host, \" huesped \"). En el cas de Access podr\u00edem incloure sent\u00e8ncies SQL en Visual Basic. D'aquesta manera s'est\u00e9n el llenguatge amfitri\u00f3 i li permet accedir a la Base de Dades. SQL \u00e9s el llenguatge est\u00e0ndard d'acc\u00e9s i manipulaci\u00f3 de Bases de Dades dels Sistemes Gestors de Bases de Dades Relacionals. A tots, absolutament a tots els SGBD Relacionales comercials es pot accedir per SQL. DDL, DQL i DML Com s'ha comentat en la pregunta anterior, SQL ens permet definir, controlar i accedir a una Base de Dades. Farem una distinci\u00f3 principal entre aquestes funcions, separant el que s\u00f3n les estructures de les taules i el contingut de les taules. En aquest sentit tindrem 3 subtipus de llenguatges: DDL ( Data Definition Language o Llenguatge de Definici\u00f3 de Dades ): permet definir, modificar o esborrar les estructures, com poden ser taules, vistes, \u00edndex, ... i fins i tot Bases de Dades. B\u00e0sicament les sent\u00e8ncies s\u00f3n 3: CREATE per a crear l'estructura ALTER per a modificar-la DROP per a esborrar-la DQL ( Data Query Language o Llenguatge de Consulta de Dades ): permet consultar dades d'una base de dades. SELECT per a consultar dades DML ( Data Manipulation Language o Llenguatge de Manipulaci\u00f3 de Dades ): permet accedir al contingut de les estructures, a les dades. Aquest acc\u00e9s pot ser de dos tipus: per a consultar o per a modificar les dades INSERT insereix noves files UPDATE modifica el contingut de files ja existents DELETE esborra files El llenguatge SQL \u00e9s m\u00e9s extens que les sent\u00e8ncies anteriors, incorporant tamb\u00e9 el que s'anomena DCL ( Data Control Language o Llenguatge de Control de Dades ), que permet controlar les dades per a donar permisos o llevar-los sobre les dades, o controlar les transaccions, ..., per\u00f2 de moment ens aconformarem amb les sent\u00e8ncies de DML i DDL, i aquestes \u00faltimes, sobretot, per a definir taules. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"1. Introducci\u00f3"},{"location":"BD_PostgreSQL_DQL/1_introducci/#1-introduccio","text":"SQL \u00e9s un llenguatge per a organitzar, gestionar i recuperar dades emmagatzemades en una Base de Dades. El nom \" SQL \" \u00e9s una abreviatura de Structured Query Language (Llenguatge Estructurat de Consultes), i com el seu nom indica, \u00e9s un llenguatge inform\u00e0tic que es pot utilitzar per a interaccions amb una Base de Dades de tipus relacional. SQL s'utilitza per a controlar totes les funcions que un SGBD proporciona als seus usuaris, incloent: Definici\u00f3 de dades . SQL permet a un usuari definir l'estructura i organitzaci\u00f3 de les dades emmagatzemades i les relacions existents entre elles (claus externes). Recuperaci\u00f3 de dades . SQL permet a un usuari o a un programa d'aplicaci\u00f3 recuperar les dades emmagatzemades de la base de dades i utilitzar-les. Manipulaci\u00f3 de dades . SQL permet a un usuari o a un programa d'aplicaci\u00f3 actualitzar la base de dades afegint noves dades, suprimint dades antigues i modificant dades pr\u00e8viament emmagatzemades. Control d'acc\u00e9s . SQL pot ser utilitzat per a restringir la capacitat d'un usuari per a recuperar, afegir i modificar dades, protegint aix\u00ed les dades guardades davant d'accessos no autoritzats. Compartici\u00f3 de dades . SQL s'utilitza per a coordinar la compartici\u00f3 de dades per part d'usuaris concurrents, assegurant que no interfereixen entre ells. Integritat de dades . SQL defineix restriccions d'integritat en la base de dades, protegint-la contra corrupcions causades per actualitzacions inconsistents o per fallades del sistema. SQL no \u00e9s realment un llenguatge inform\u00e0tic complet tal com JAVA, C o Python. SQL no disposa de la sent\u00e8ncia IF per a examinar condicions, ni de les sent\u00e8ncies WHILE o FOR per a fer bucles, per exemple. En compte d'aix\u00f2, SQL \u00e9s un subllenguatge de base de dades, que consta d'unes trenta sent\u00e8ncies especialitzades per a tasques de gesti\u00f3 de bases de dades, per\u00f2 nom\u00e9s 7 s\u00f3n les sent\u00e8ncies principals . Tamb\u00e9 es diu que \u00e9s un llenguatge de quarta generaci\u00f3 perqu\u00e8 en ell es diu quina informaci\u00f3 es vol, sense especificar exactament com s'aconsegueix aquesta informaci\u00f3. Tamb\u00e9 es diu que \u00e9s un llenguatge orientat a conjunt de registres , ja que una sent\u00e8ncia pot tornar un conjunt de registres. A\u00e7\u00f2 \u00e9s un gran avantatge amb els llenguatges de tercera generaci\u00f3, que nom\u00e9s podien treballar registre a registre. Dues s\u00f3n les maneres d'executar sent\u00e8ncies SQL. De forma interactiva : s'escriu una sent\u00e8ncia SQL, i s'executa, tornant normalment un conjunt de registres que es presentaran en forma tabular. En Access el lloc on procedir d'aquesta manera \u00e9s en les consultes , triant Vista SQL . Tindrem lloc per escriure la sent\u00e8ncia tal i com es mostra en la primera imatge. En la segona imatge, es mostra una consulta ja feta en el tema anterior, per\u00f2 veient-la en SQL. En la tercera hem executat la consulta: Dins d'un programa escrit en un altre llenguatge, que actuar\u00e0 com llenguatge amfitri\u00f3 (i el SQL seria el llenguatge host, \" huesped \"). En el cas de Access podr\u00edem incloure sent\u00e8ncies SQL en Visual Basic. D'aquesta manera s'est\u00e9n el llenguatge amfitri\u00f3 i li permet accedir a la Base de Dades. SQL \u00e9s el llenguatge est\u00e0ndard d'acc\u00e9s i manipulaci\u00f3 de Bases de Dades dels Sistemes Gestors de Bases de Dades Relacionals. A tots, absolutament a tots els SGBD Relacionales comercials es pot accedir per SQL.","title":"1. Introducci\u00f3"},{"location":"BD_PostgreSQL_DQL/1_introducci/#ddl-dql-i-dml","text":"Com s'ha comentat en la pregunta anterior, SQL ens permet definir, controlar i accedir a una Base de Dades. Farem una distinci\u00f3 principal entre aquestes funcions, separant el que s\u00f3n les estructures de les taules i el contingut de les taules. En aquest sentit tindrem 3 subtipus de llenguatges: DDL ( Data Definition Language o Llenguatge de Definici\u00f3 de Dades ): permet definir, modificar o esborrar les estructures, com poden ser taules, vistes, \u00edndex, ... i fins i tot Bases de Dades. B\u00e0sicament les sent\u00e8ncies s\u00f3n 3: CREATE per a crear l'estructura ALTER per a modificar-la DROP per a esborrar-la DQL ( Data Query Language o Llenguatge de Consulta de Dades ): permet consultar dades d'una base de dades. SELECT per a consultar dades DML ( Data Manipulation Language o Llenguatge de Manipulaci\u00f3 de Dades ): permet accedir al contingut de les estructures, a les dades. Aquest acc\u00e9s pot ser de dos tipus: per a consultar o per a modificar les dades INSERT insereix noves files UPDATE modifica el contingut de files ja existents DELETE esborra files El llenguatge SQL \u00e9s m\u00e9s extens que les sent\u00e8ncies anteriors, incorporant tamb\u00e9 el que s'anomena DCL ( Data Control Language o Llenguatge de Control de Dades ), que permet controlar les dades per a donar permisos o llevar-los sobre les dades, o controlar les transaccions, ..., per\u00f2 de moment ens aconformarem amb les sent\u00e8ncies de DML i DDL, i aquestes \u00faltimes, sobretot, per a definir taules. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"DDL, DQL i DML"},{"location":"BD_PostgreSQL_DQL/1_la_consulta_select/","text":"1. La consulta SELECT Com el mateix nom indica SQL ( Structured Query Language ), la consulta o interrogaci\u00f3 de la Base de Dades \u00e9s l'\u00e0nima del SQL. I la instrucci\u00f3 que ens ho permet \u00e9s SELECT . \u00c9s una instrucci\u00f3 molt flexible i de molta pot\u00e8ncia, que permet consultar dades d'una o m\u00e9s taules, filtrar per files i/o columnes, ordenar el resultat, agrupar les dades (comptant o sumant alguna columna), ... Fins i tot permet crear taules noves que serien el resultat d'una consulta d'altres taules. Veurem a continuaci\u00f3 la sintaxi general de la instrucci\u00f3, i posteriorment cadascuna de les cl\u00e0usules: Sintaxi SELECT [DISTINCT] <columnes> [ INTO <cl\u00e0usula> ] FROM <cl\u00e0usula> [ WHERE <cl\u00e0usula> ] [ GROUP BY <cl\u00e0usula> ] [ HAVING <cl\u00e0usula> ] [ ORDER BY <cl\u00e0usula> ] [ LIMIT num1 OFFSET num2 ] Com veieu, les \u00faniques cl\u00e0usules obligat\u00f2ries s\u00f3n la del SELECT (on es diu les columnes que volem que isquen com a resultat) i la del FROM (on es diu d'on venen les dades). Nota En PostgreSQL no es distingeix entre maj\u00fascules i min\u00fascules. Millor dit, PostgreSQL passa de maj\u00fascules a min\u00fascules tots els noms de taula o de camp o del que siga, excepte si van entre cometes dobles, que aleshores es respecten may\u00fascules i min\u00fascules. Com a q\u00fcesti\u00f3 d'estil, jo no pose mai entre cometes els noms de taules i camps. I per a una millor lectura, intentar\u00e9 posar sempre els noms de taula en maj\u00fascules, i els noms de camp en min\u00fascules. Tamb\u00e9 posar\u00e9 en maj\u00fascules les cl\u00e0usules de sent\u00e8ncies SQL (SELECT , FROM , WHERE , ...). Per\u00f2 recordeu que \u00e9s per a una millor lectura. Podria anar tot en min\u00fascules perfectament. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"1. La consulta SELECT"},{"location":"BD_PostgreSQL_DQL/1_la_consulta_select/#1-la-consulta-select","text":"Com el mateix nom indica SQL ( Structured Query Language ), la consulta o interrogaci\u00f3 de la Base de Dades \u00e9s l'\u00e0nima del SQL. I la instrucci\u00f3 que ens ho permet \u00e9s SELECT . \u00c9s una instrucci\u00f3 molt flexible i de molta pot\u00e8ncia, que permet consultar dades d'una o m\u00e9s taules, filtrar per files i/o columnes, ordenar el resultat, agrupar les dades (comptant o sumant alguna columna), ... Fins i tot permet crear taules noves que serien el resultat d'una consulta d'altres taules. Veurem a continuaci\u00f3 la sintaxi general de la instrucci\u00f3, i posteriorment cadascuna de les cl\u00e0usules: Sintaxi SELECT [DISTINCT] <columnes> [ INTO <cl\u00e0usula> ] FROM <cl\u00e0usula> [ WHERE <cl\u00e0usula> ] [ GROUP BY <cl\u00e0usula> ] [ HAVING <cl\u00e0usula> ] [ ORDER BY <cl\u00e0usula> ] [ LIMIT num1 OFFSET num2 ] Com veieu, les \u00faniques cl\u00e0usules obligat\u00f2ries s\u00f3n la del SELECT (on es diu les columnes que volem que isquen com a resultat) i la del FROM (on es diu d'on venen les dades). Nota En PostgreSQL no es distingeix entre maj\u00fascules i min\u00fascules. Millor dit, PostgreSQL passa de maj\u00fascules a min\u00fascules tots els noms de taula o de camp o del que siga, excepte si van entre cometes dobles, que aleshores es respecten may\u00fascules i min\u00fascules. Com a q\u00fcesti\u00f3 d'estil, jo no pose mai entre cometes els noms de taules i camps. I per a una millor lectura, intentar\u00e9 posar sempre els noms de taula en maj\u00fascules, i els noms de camp en min\u00fascules. Tamb\u00e9 posar\u00e9 en maj\u00fascules les cl\u00e0usules de sent\u00e8ncies SQL (SELECT , FROM , WHERE , ...). Per\u00f2 recordeu que \u00e9s per a una millor lectura. Podria anar tot en min\u00fascules perfectament. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"1. La consulta SELECT"},{"location":"BD_PostgreSQL_DQL/2_client_dbeaver_installaci_i_confiuraci/","text":"2 DBeaver 2.1 Instal\u00b7laci\u00f3 i configuraci\u00f3 Com ja s'ha comentat, en aquest tema utilitzarem el Sistema Gestor de Bases de Dades PostgreSQL . Aquest SGBD utilitza l'arquitectura client-servidor . Aix\u00f2 significa que hi ha un servidor central amb el PostgreSQL instal\u00b7lat, i hi haur\u00e0 molts clients que es connectaran a aquest servidor. Es pot fer des de la mateixa m\u00e0quina on est\u00e0 instal\u00b7lat el servidor, o des d'una altra. En el nostre cas, el servidor ja est\u00e0 en marxa i funcionant. Podrem accedir a ell tant des de dins de l'Institut com des de fora. A nosaltres, per a poder connectar amb el servidor PostgreSQL ens fa falta el client de PostgreSQL . Instal\u00b7larem DBeaver , un programa que est\u00e0 pegant molt fort i ens permet accedir a qualsevol Sistema Gestor de Bases de Dades molt c\u00f2modament. En els ordinadors de l'Institut ja el tenim instal\u00b7lat. En casa us l'haureu d'instal\u00b7lar per\u00f2 la seua instal\u00b7laci\u00f3 no ofereix cap problema. Haureu d'anar a la p\u00e0gina de DBeaver, concretament a la de Downloads: https://dbeaver.io/download/ Triarem la versi\u00f3 Comunity Edition , amb ella tindrem de sobres i \u00e9s totalment lliure. Com veieu es pot instal\u00b7lar sense problemes en Windows, Mac i/o Linux La versi\u00f3 Enterprise Edition tamb\u00e9 ens permetria accedir a molt\u00edssimes Bases de Dades NoSQL. Com veieu molt interessant. Com hem dit amb la versi\u00f3 Comunity Edition tindrem m\u00e9s que suficient. Tant en Linux com en Windows tenim la possibilitat de baixar-nos un fitxer comprimit (zip o tar.gz respectivament) que nom\u00e9s haurem de descomprimir i buscar l'executable. Tamb\u00e9 tenim la possibilitat de baixar-nos l'instal\u00b7lador, que en Windows seria un executable i en Linux un paquet. Per\u00f2 la primera opci\u00f3 del fitxer comprimit ens anir\u00e0 b\u00e9. La versi\u00f3 en el moment de fer aquestos apunts \u00e9s la 21.2.4 Una vegada feta la instal\u00b7laci\u00f3 haurem de fer la connexi\u00f3 amb el SGBD que en el nostre cas ser\u00e0 PostgreSQL. Per\u00f2 connectar a qualsevol altre SGBD seria exactament igual. La primera vegada que arranquem el programa, segurament ens demanar\u00e0 per fer la primera connexi\u00f3. Arribarem a la mateixa finestra cada vegada que anem a fer una nova connexi\u00f3. Primera connexi\u00f3 a PostgreSQL: geo Especificarem que volem connectar a PostgreSQL i a continuaci\u00f3 donarem les dades de connexi\u00f3, que s\u00f3n aquestes: Servidor ( Host ): 89.36.214.106 Base de Dades ( Database ): geo Usuari ( Username ): geo Contrasenya ( Password ): geo En aquesta Base de Dades tindrem unes taules que ens serviran per a fer els exercicis de SQL. Comentarem la seua estructura m\u00e9s endavant. Aquestes s\u00f3n les finestres on especificar\u00edem l'anterior: Segona connexi\u00f3 a PostgreSQL: factura Per als exercicis treballarem sobre una altra Base de Dades m\u00e9s completa que ens done m\u00e9s joc a l'hora de fer les sent\u00e8ncies SQL. La Base de Dades s'anomena factura, i s'ha de connectar amb l'usuari factura amb contrasenya factura. Comentarem la seua estructura m\u00e9s endavant. Aquestes s\u00f3n les dades de connexi\u00f3: Servidor ( Host ): 89.36.214.106 Base de Dades ( Database ): factura Usuari ( Username ): factura_alu Contrasenya ( Password ): factura_alu Aquestes s\u00f3n les pantalles on far\u00edem la connexi\u00f3: 2.2 Utilitzaci\u00f3 Una vegada feta la connexi\u00f3, DBeaver ens permetr\u00e0 navegar per les taules i altres objectes de la Base de Dades, inspeccionar les taules, i el m\u00e9s important per a nosaltres, executar sent\u00e8ncies SQL de forma c\u00f2moda. En la seg\u00fcent imatge es presenten algunes de les seues parts i caracteristiques. En ella s'ha fet doble clic sobre una taula, COMARQUES, per veure les seues caracter\u00edstiques: Tamb\u00e9 podem veure les dades, i fins i tot afegir noves files, esborrar o modificar les existents. Es pot ordenar les files i fer filtres: I tamb\u00e9 tindrem la possibilitat d'executar consultes SQL (en la primera imatge es mostra com arribar). En la finestra de sent\u00e8ncies SQL podrem editar la consulta de forma c\u00f2moda (ens d\u00f3na molta ajuda per a no cometre errors sint\u00e0ctics) i tamb\u00e9 ens mostra el resultat. Podem modificar quantes vegades vulguem. i des del menu File podrem guardar la consulta, cosa que farem per a tots els exercicis del tema: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"2. DBeaver"},{"location":"BD_PostgreSQL_DQL/2_client_dbeaver_installaci_i_confiuraci/#2-dbeaver","text":"","title":"2 DBeaver"},{"location":"BD_PostgreSQL_DQL/2_client_dbeaver_installaci_i_confiuraci/#21-installacio-i-configuracio","text":"Com ja s'ha comentat, en aquest tema utilitzarem el Sistema Gestor de Bases de Dades PostgreSQL . Aquest SGBD utilitza l'arquitectura client-servidor . Aix\u00f2 significa que hi ha un servidor central amb el PostgreSQL instal\u00b7lat, i hi haur\u00e0 molts clients que es connectaran a aquest servidor. Es pot fer des de la mateixa m\u00e0quina on est\u00e0 instal\u00b7lat el servidor, o des d'una altra. En el nostre cas, el servidor ja est\u00e0 en marxa i funcionant. Podrem accedir a ell tant des de dins de l'Institut com des de fora. A nosaltres, per a poder connectar amb el servidor PostgreSQL ens fa falta el client de PostgreSQL . Instal\u00b7larem DBeaver , un programa que est\u00e0 pegant molt fort i ens permet accedir a qualsevol Sistema Gestor de Bases de Dades molt c\u00f2modament. En els ordinadors de l'Institut ja el tenim instal\u00b7lat. En casa us l'haureu d'instal\u00b7lar per\u00f2 la seua instal\u00b7laci\u00f3 no ofereix cap problema. Haureu d'anar a la p\u00e0gina de DBeaver, concretament a la de Downloads: https://dbeaver.io/download/ Triarem la versi\u00f3 Comunity Edition , amb ella tindrem de sobres i \u00e9s totalment lliure. Com veieu es pot instal\u00b7lar sense problemes en Windows, Mac i/o Linux La versi\u00f3 Enterprise Edition tamb\u00e9 ens permetria accedir a molt\u00edssimes Bases de Dades NoSQL. Com veieu molt interessant. Com hem dit amb la versi\u00f3 Comunity Edition tindrem m\u00e9s que suficient. Tant en Linux com en Windows tenim la possibilitat de baixar-nos un fitxer comprimit (zip o tar.gz respectivament) que nom\u00e9s haurem de descomprimir i buscar l'executable. Tamb\u00e9 tenim la possibilitat de baixar-nos l'instal\u00b7lador, que en Windows seria un executable i en Linux un paquet. Per\u00f2 la primera opci\u00f3 del fitxer comprimit ens anir\u00e0 b\u00e9. La versi\u00f3 en el moment de fer aquestos apunts \u00e9s la 21.2.4 Una vegada feta la instal\u00b7laci\u00f3 haurem de fer la connexi\u00f3 amb el SGBD que en el nostre cas ser\u00e0 PostgreSQL. Per\u00f2 connectar a qualsevol altre SGBD seria exactament igual. La primera vegada que arranquem el programa, segurament ens demanar\u00e0 per fer la primera connexi\u00f3. Arribarem a la mateixa finestra cada vegada que anem a fer una nova connexi\u00f3. Primera connexi\u00f3 a PostgreSQL: geo Especificarem que volem connectar a PostgreSQL i a continuaci\u00f3 donarem les dades de connexi\u00f3, que s\u00f3n aquestes: Servidor ( Host ): 89.36.214.106 Base de Dades ( Database ): geo Usuari ( Username ): geo Contrasenya ( Password ): geo En aquesta Base de Dades tindrem unes taules que ens serviran per a fer els exercicis de SQL. Comentarem la seua estructura m\u00e9s endavant. Aquestes s\u00f3n les finestres on especificar\u00edem l'anterior: Segona connexi\u00f3 a PostgreSQL: factura Per als exercicis treballarem sobre una altra Base de Dades m\u00e9s completa que ens done m\u00e9s joc a l'hora de fer les sent\u00e8ncies SQL. La Base de Dades s'anomena factura, i s'ha de connectar amb l'usuari factura amb contrasenya factura. Comentarem la seua estructura m\u00e9s endavant. Aquestes s\u00f3n les dades de connexi\u00f3: Servidor ( Host ): 89.36.214.106 Base de Dades ( Database ): factura Usuari ( Username ): factura_alu Contrasenya ( Password ): factura_alu Aquestes s\u00f3n les pantalles on far\u00edem la connexi\u00f3:","title":"2.1 Instal\u00b7laci\u00f3 i configuraci\u00f3"},{"location":"BD_PostgreSQL_DQL/2_client_dbeaver_installaci_i_confiuraci/#22-utilitzacio","text":"Una vegada feta la connexi\u00f3, DBeaver ens permetr\u00e0 navegar per les taules i altres objectes de la Base de Dades, inspeccionar les taules, i el m\u00e9s important per a nosaltres, executar sent\u00e8ncies SQL de forma c\u00f2moda. En la seg\u00fcent imatge es presenten algunes de les seues parts i caracteristiques. En ella s'ha fet doble clic sobre una taula, COMARQUES, per veure les seues caracter\u00edstiques: Tamb\u00e9 podem veure les dades, i fins i tot afegir noves files, esborrar o modificar les existents. Es pot ordenar les files i fer filtres: I tamb\u00e9 tindrem la possibilitat d'executar consultes SQL (en la primera imatge es mostra com arribar). En la finestra de sent\u00e8ncies SQL podrem editar la consulta de forma c\u00f2moda (ens d\u00f3na molta ajuda per a no cometre errors sint\u00e0ctics) i tamb\u00e9 ens mostra el resultat. Podem modificar quantes vegades vulguem. i des del menu File podrem guardar la consulta, cosa que farem per a tots els exercicis del tema: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"2.2 Utilitzaci\u00f3"},{"location":"BD_PostgreSQL_DQL/2_consulta_bsica/","text":"2. Consulta b\u00e0sica El m\u00ednim que s'ha d'indicar en una instrucci\u00f3 SELECT \u00e9s les columnes que volem i la seua proced\u00e8ncia, que pot ser una o m\u00e9s d'una taula. Sintaxi SELECT <columnes> FROM <cl\u00e0usula> Opcionalment la sent\u00e8ncia pot acabar en punt i coma . En psql \u00e9s obligatori acabar en punt i coma, ja que \u00e9s la manera que t\u00e9 de saber que acaba la instrucci\u00f3 (una instrucci\u00f3 pot ocupar m\u00e9s d'una l\u00ednia) I una altra consideraci\u00f3 important \u00e9s que en PostgreSQL els noms dels objectes (taules, columnes, ...) poden constar de m\u00e9s d'una paraula. Si el nom nom\u00e9s consta d'una paraula es pot posar sense m\u00e9s problemes, per\u00f2 si consta de m\u00e9s d'una paraula (amb espis en blanc pel mig) o t\u00e9 algun car\u00e0cter especial, o coincideix amb alguna paraula reservada (per exemple any ), haur\u00e0 d'anar entre cometes dobles . Per a estalviar problemes, \u00e9s una bona pr\u00e0ctica fer els noms sempre d'una paraula (si es volen posar dues, unides pel gui\u00f3 baix). En podrem posar (separades per comes ): noms de les columnes que volem; si hi ha confusi\u00f3 entre noms de camps de distintes taules, haurem de posar Taula.columna . ***** : indica totes les columnes. Taula. * : indica totes les columnes de la taula. Funcions (veure apartat Operadors i Funcions de Postgres ) Constants : son valors que posem directament. Els tipus de constants s\u00f3n: Num\u00e8riques : es posen tal qual, amb punt decimal (no pot anar coma decimal, perqu\u00e8 serveix per a separar les columnes) Alfaum\u00e8riques : es posen entre cometes simples Per a altres tipus (com per exemple data-hora), posem la constant entre cometes simples, i PostgreSQL far\u00e0 la conversi\u00f3 Expressions que utilitzen operadors per a combinar columnes, funcions, constants num\u00e8riques o alfanum\u00e8riques, ... En la del FROM posarem la taula o les taules (separades per comes) d'on venen les dades. Aix\u00ed el seg\u00fcent exemple trau tota la informaci\u00f3 de la taula COMARQUES, \u00e9s a dir totes les files i totes les columnes: SELECT * FROM COMARQUES; Mentre que la seg\u00fcent nom\u00e9s trau el nom: SELECT nom_c FROM COMARQUES; En el seg\u00fcent exemple es trau el nom de cada poblaci\u00f3, els habitants, l'extensi\u00f3 i la densitat de poblaci\u00f3 (habitants partit per extensi\u00f3): SELECT nom , poblacio , extensio , poblacio/extensio FROM POBLACIONS; I en aquest traem el nom de cada poble, l'altura i la mitat de la seua altura (cosa un poc absurda per\u00f2 que serveix per a remarcar que si posem una constant num\u00e8rica, hem de posar el punt decimal , no la coma decimal, ja que la coma serveix per a separar els camps) : SELECT nom , altura , altura * 0.5 FROM POBLACIONS; Exemples 1) Traure tota la informaci\u00f3 de la taula POBLACIONS. SELECT * FROM POBLACIONS; 2) Traure el nom i l'altura de totes les poblacions. SELECT nom, altura FROM POBLACIONS; 3) Traure el nom de les poblacions, el n\u00famero d'habitants, i aquest n\u00famero incrementat en un 5%. SELECT nom, poblacio, poblacio * 1.05 FROM POBLACIONS; Observa com hem d'utilitzar el punt decimal i no la coma decimal, ja que la coma serveix per a separar els camps de la consulta SQL 4) Traure nom, latitud i els graus de la latitud de totes les poblacions. Per a traure els graus de la latitud traurem els car\u00e0cters de l'esquerra, fins el primer el car\u00e0cter \u00ba. SELECT nom, latitud, SUBSTR(latitud,1,STRPOS(latitud,'\u00ba')-1) FROM POBLACIONS; Exercicis En la BD factura , connectant com a usuari factura_alu : Ex_1 Traure tota la informaci\u00f3 dels pobles. Ex_2 Traure el codi postal, el nom i l'adre\u00e7a, per aquest ordre, de tots els venedors. Ex_3 Traure el codi d'article, la descripci\u00f3, preu i preu incrementat en un 5%, de tots els articles. Ex_4 Traure la informaci\u00f3 dels clients amb el seg\u00fcent format (ha d'anar tot en una columna): Damborenea Corbato, Alicia. CALLE MADRID, 83 (12425) Fixeu-vos que est\u00e0 tot en una columna, i per tant haureu de concatenar de la forma adequada. Fixeu-vos tamb\u00e9 que en en el nom nom\u00e9s les inicials estan en maj\u00fascules Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"2. Consulta b\u00e0sica"},{"location":"BD_PostgreSQL_DQL/2_consulta_bsica/#2-consulta-basica","text":"El m\u00ednim que s'ha d'indicar en una instrucci\u00f3 SELECT \u00e9s les columnes que volem i la seua proced\u00e8ncia, que pot ser una o m\u00e9s d'una taula. Sintaxi SELECT <columnes> FROM <cl\u00e0usula> Opcionalment la sent\u00e8ncia pot acabar en punt i coma . En psql \u00e9s obligatori acabar en punt i coma, ja que \u00e9s la manera que t\u00e9 de saber que acaba la instrucci\u00f3 (una instrucci\u00f3 pot ocupar m\u00e9s d'una l\u00ednia) I una altra consideraci\u00f3 important \u00e9s que en PostgreSQL els noms dels objectes (taules, columnes, ...) poden constar de m\u00e9s d'una paraula. Si el nom nom\u00e9s consta d'una paraula es pot posar sense m\u00e9s problemes, per\u00f2 si consta de m\u00e9s d'una paraula (amb espis en blanc pel mig) o t\u00e9 algun car\u00e0cter especial, o coincideix amb alguna paraula reservada (per exemple any ), haur\u00e0 d'anar entre cometes dobles . Per a estalviar problemes, \u00e9s una bona pr\u00e0ctica fer els noms sempre d'una paraula (si es volen posar dues, unides pel gui\u00f3 baix). En podrem posar (separades per comes ): noms de les columnes que volem; si hi ha confusi\u00f3 entre noms de camps de distintes taules, haurem de posar Taula.columna . ***** : indica totes les columnes. Taula. * : indica totes les columnes de la taula. Funcions (veure apartat Operadors i Funcions de Postgres ) Constants : son valors que posem directament. Els tipus de constants s\u00f3n: Num\u00e8riques : es posen tal qual, amb punt decimal (no pot anar coma decimal, perqu\u00e8 serveix per a separar les columnes) Alfaum\u00e8riques : es posen entre cometes simples Per a altres tipus (com per exemple data-hora), posem la constant entre cometes simples, i PostgreSQL far\u00e0 la conversi\u00f3 Expressions que utilitzen operadors per a combinar columnes, funcions, constants num\u00e8riques o alfanum\u00e8riques, ... En la del FROM posarem la taula o les taules (separades per comes) d'on venen les dades. Aix\u00ed el seg\u00fcent exemple trau tota la informaci\u00f3 de la taula COMARQUES, \u00e9s a dir totes les files i totes les columnes: SELECT * FROM COMARQUES; Mentre que la seg\u00fcent nom\u00e9s trau el nom: SELECT nom_c FROM COMARQUES; En el seg\u00fcent exemple es trau el nom de cada poblaci\u00f3, els habitants, l'extensi\u00f3 i la densitat de poblaci\u00f3 (habitants partit per extensi\u00f3): SELECT nom , poblacio , extensio , poblacio/extensio FROM POBLACIONS; I en aquest traem el nom de cada poble, l'altura i la mitat de la seua altura (cosa un poc absurda per\u00f2 que serveix per a remarcar que si posem una constant num\u00e8rica, hem de posar el punt decimal , no la coma decimal, ja que la coma serveix per a separar els camps) : SELECT nom , altura , altura * 0.5 FROM POBLACIONS; Exemples 1) Traure tota la informaci\u00f3 de la taula POBLACIONS. SELECT * FROM POBLACIONS; 2) Traure el nom i l'altura de totes les poblacions. SELECT nom, altura FROM POBLACIONS; 3) Traure el nom de les poblacions, el n\u00famero d'habitants, i aquest n\u00famero incrementat en un 5%. SELECT nom, poblacio, poblacio * 1.05 FROM POBLACIONS; Observa com hem d'utilitzar el punt decimal i no la coma decimal, ja que la coma serveix per a separar els camps de la consulta SQL 4) Traure nom, latitud i els graus de la latitud de totes les poblacions. Per a traure els graus de la latitud traurem els car\u00e0cters de l'esquerra, fins el primer el car\u00e0cter \u00ba. SELECT nom, latitud, SUBSTR(latitud,1,STRPOS(latitud,'\u00ba')-1) FROM POBLACIONS;","title":"2. Consulta b\u00e0sica"},{"location":"BD_PostgreSQL_DQL/2_consulta_bsica/#exercicis","text":"En la BD factura , connectant com a usuari factura_alu : Ex_1 Traure tota la informaci\u00f3 dels pobles. Ex_2 Traure el codi postal, el nom i l'adre\u00e7a, per aquest ordre, de tots els venedors. Ex_3 Traure el codi d'article, la descripci\u00f3, preu i preu incrementat en un 5%, de tots els articles. Ex_4 Traure la informaci\u00f3 dels clients amb el seg\u00fcent format (ha d'anar tot en una columna): Damborenea Corbato, Alicia. CALLE MADRID, 83 (12425) Fixeu-vos que est\u00e0 tot en una columna, i per tant haureu de concatenar de la forma adequada. Fixeu-vos tamb\u00e9 que en en el nom nom\u00e9s les inicials estan en maj\u00fascules Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/3_dades_dels_exemples_i_els_exercicis/","text":"3. Esquemes Factura i Geo Dades dels exemples Tots els exemples que es mostraran en aquest tema s'intentaran fer sobre la connexi\u00f3 que ja tenim feta, \u00e9s a dir, al servidor de l'Institut, connectant com a usuari geo (contresenya geo ) a la Base de Dades geo . \u00c9s una Base de Dades molt senzilleta, amb nom\u00e9s 3 taules, cosa que ajudar\u00e0 a una f\u00e0cil comprensi\u00f3 de la seua estructura. Aquest \u00e9s l'esquema en el Model Entitat-Relaci\u00f3 i en el Model Relacional: Dades dels exercicis Per als exercicis treballarem sobre una altra Base de Dades m\u00e9s completa que ens done m\u00e9s joc a l'hora de fer les sent\u00e8ncies SQL. La Base de Dades s'anomena factura , i s'ha de connectar amb l'usuari factura amb contrasenya factura . Aquesta seria la seua estructura, tamb\u00e9 en Model Entitat-Relaci\u00f3 i Model Relacional. Recordeu que en el apartat Dbeaver hav\u00edem fet les connexions a cadascuna de les 2 Bases de Dades anteriors. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"3 Dades dels exemples i els exercicis"},{"location":"BD_PostgreSQL_DQL/3_dades_dels_exemples_i_els_exercicis/#3-esquemes-factura-i-geo","text":"Dades dels exemples Tots els exemples que es mostraran en aquest tema s'intentaran fer sobre la connexi\u00f3 que ja tenim feta, \u00e9s a dir, al servidor de l'Institut, connectant com a usuari geo (contresenya geo ) a la Base de Dades geo . \u00c9s una Base de Dades molt senzilleta, amb nom\u00e9s 3 taules, cosa que ajudar\u00e0 a una f\u00e0cil comprensi\u00f3 de la seua estructura. Aquest \u00e9s l'esquema en el Model Entitat-Relaci\u00f3 i en el Model Relacional: Dades dels exercicis Per als exercicis treballarem sobre una altra Base de Dades m\u00e9s completa que ens done m\u00e9s joc a l'hora de fer les sent\u00e8ncies SQL. La Base de Dades s'anomena factura , i s'ha de connectar amb l'usuari factura amb contrasenya factura . Aquesta seria la seua estructura, tamb\u00e9 en Model Entitat-Relaci\u00f3 i Model Relacional. Recordeu que en el apartat Dbeaver hav\u00edem fet les connexions a cadascuna de les 2 Bases de Dades anteriors. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"3. Esquemes Factura i Geo"},{"location":"BD_PostgreSQL_DQL/3_lies_en_les_columnes/","text":"3. \u00c0lies en les columnes Tenim tamb\u00e9 la possibilitat de donar noms ( \u00e0lies ) a les columnes que apareixeran en la cap\u00e7alera de les columnes corresponents en el resultat. Sintaxi SELECT columna1 [AS \u00e0lias1] [ , columna2 [AS \u00e0lias2] ] FROM TAULA; Si volem que en la cap\u00e7alera apareguen m\u00e9s d'una paraula, les haurem de tancar amb cometes dobles ( \" ). Per exemple: SELECT cod_m AS \"Codi Municipi\" , nom FROM POBLACIONS; \u00c9s especialment \u00fatil la utilitzaci\u00f3 d'\u00e0lies quan posem una expressi\u00f3, en compte d'una \u00fanica columna. Si no posem \u00e0lies, apareix en la cap\u00e7alera una cosa semblant a ?column? . SELECT nom_c || ' (' || provincia || ')' AS \" Comarca (provincia)\" FROM COMARQUES; I a banda del seu valor est\u00e8tic, m\u00e9s avant veurem sent\u00e8ncies SQL en les quals obligat\u00f2riament haurem de posar \u00e0lies a les columnes que siguen el resultat d'una expressi\u00f3. Exemples 1) Traure de les poblacions, el nom i el n\u00famero d'habitants (camp poblacio), aquest \u00faltim el nom habitants . SELECT nom, poblacio AS habitants FROM POBLACIONS; 2) Traure tots els camps de la taula INSTITUTS de forma elegant. SELECT codi AS \"Codi Institut\", nom as Nom, adreca AS Adre\u00e7a, numero AS N\u00famero, codpostal AS \"Codi Postal\", cod_m AS \"Codi Municipi\" FROM INSTITUTS; Si volem que totes les cap\u00e7aleres comencen per maj\u00fascula, haurem de posar tots els \u00e0lies entre cometes dobles, encara que nom\u00e9s consten d'una paruala SELECT codi AS \"Codi Institut\", nom as \"Nom\", adreca AS \"Adre\u00e7a\", numero AS \"N\u00famero\", codpostal AS \"Codi Postal\", cod_m AS \"Codi Municipi\" FROM INSTITUTS; Exercicis Ex_5 Traure el num_f, data i cod_ven de les factures amb les seg\u00fcents cap\u00e7aleres respectivament: N\u00famero Factura , data i Codi Venedor Ex_6 Donar \u00e0lias als camps que ho necessiten de la taula ARTICLE. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"3. \u00c0lies en les columnes"},{"location":"BD_PostgreSQL_DQL/3_lies_en_les_columnes/#3-alies-en-les-columnes","text":"Tenim tamb\u00e9 la possibilitat de donar noms ( \u00e0lies ) a les columnes que apareixeran en la cap\u00e7alera de les columnes corresponents en el resultat. Sintaxi SELECT columna1 [AS \u00e0lias1] [ , columna2 [AS \u00e0lias2] ] FROM TAULA; Si volem que en la cap\u00e7alera apareguen m\u00e9s d'una paraula, les haurem de tancar amb cometes dobles ( \" ). Per exemple: SELECT cod_m AS \"Codi Municipi\" , nom FROM POBLACIONS; \u00c9s especialment \u00fatil la utilitzaci\u00f3 d'\u00e0lies quan posem una expressi\u00f3, en compte d'una \u00fanica columna. Si no posem \u00e0lies, apareix en la cap\u00e7alera una cosa semblant a ?column? . SELECT nom_c || ' (' || provincia || ')' AS \" Comarca (provincia)\" FROM COMARQUES; I a banda del seu valor est\u00e8tic, m\u00e9s avant veurem sent\u00e8ncies SQL en les quals obligat\u00f2riament haurem de posar \u00e0lies a les columnes que siguen el resultat d'una expressi\u00f3. Exemples 1) Traure de les poblacions, el nom i el n\u00famero d'habitants (camp poblacio), aquest \u00faltim el nom habitants . SELECT nom, poblacio AS habitants FROM POBLACIONS; 2) Traure tots els camps de la taula INSTITUTS de forma elegant. SELECT codi AS \"Codi Institut\", nom as Nom, adreca AS Adre\u00e7a, numero AS N\u00famero, codpostal AS \"Codi Postal\", cod_m AS \"Codi Municipi\" FROM INSTITUTS; Si volem que totes les cap\u00e7aleres comencen per maj\u00fascula, haurem de posar tots els \u00e0lies entre cometes dobles, encara que nom\u00e9s consten d'una paruala SELECT codi AS \"Codi Institut\", nom as \"Nom\", adreca AS \"Adre\u00e7a\", numero AS \"N\u00famero\", codpostal AS \"Codi Postal\", cod_m AS \"Codi Municipi\" FROM INSTITUTS;","title":"3. \u00c0lies en les columnes"},{"location":"BD_PostgreSQL_DQL/3_lies_en_les_columnes/#exercicis","text":"Ex_5 Traure el num_f, data i cod_ven de les factures amb les seg\u00fcents cap\u00e7aleres respectivament: N\u00famero Factura , data i Codi Venedor Ex_6 Donar \u00e0lias als camps que ho necessiten de la taula ARTICLE. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/4_client_dbeaver_utilitzaci/","text":"4. Client DBeaver: utilitzaci\u00f3 Una vegada feta la connexi\u00f3, DBeaver ens permetr\u00e0 navegar per les taules i altres objectes de la Base de Dades, inspeccionar les taules, i el m\u00e9s important per a nosaltres, executar sent\u00e8ncies SQL de forma c\u00f2moda. En la seg\u00fcent imatge es presenten algunes de les seues parts i caracteristiques. En ella s'ha fet doble clic sobre una taula, COMARQUES, per veure les seues caracter\u00edstiques: Tamb\u00e9 podem veure les dades, i fins i tot afegir noves files, esborrar o modificar les existents. Es pot ordenar les files i fer filtres: I tamb\u00e9 tindrem la possibilitat d'executar consultes SQL (en la primera imatge es mostra com arribar). En la finestra de sent\u00e8ncies SQL podrem editar la consulta de forma c\u00f2moda (ens d\u00f3na molta ajuda per a no cometre errors sint\u00e0ctics) i tamb\u00e9 ens mostra el resultat. Podem modificar quantes vegades vulguem. i des del menu File podrem guardar la consulta, cosa que farem per a tots els exercicis del tema: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4. Client DBeaver: utilitzaci\u00f3"},{"location":"BD_PostgreSQL_DQL/4_client_dbeaver_utilitzaci/#4-client-dbeaver-utilitzacio","text":"Una vegada feta la connexi\u00f3, DBeaver ens permetr\u00e0 navegar per les taules i altres objectes de la Base de Dades, inspeccionar les taules, i el m\u00e9s important per a nosaltres, executar sent\u00e8ncies SQL de forma c\u00f2moda. En la seg\u00fcent imatge es presenten algunes de les seues parts i caracteristiques. En ella s'ha fet doble clic sobre una taula, COMARQUES, per veure les seues caracter\u00edstiques: Tamb\u00e9 podem veure les dades, i fins i tot afegir noves files, esborrar o modificar les existents. Es pot ordenar les files i fer filtres: I tamb\u00e9 tindrem la possibilitat d'executar consultes SQL (en la primera imatge es mostra com arribar). En la finestra de sent\u00e8ncies SQL podrem editar la consulta de forma c\u00f2moda (ens d\u00f3na molta ajuda per a no cometre errors sint\u00e0ctics) i tamb\u00e9 ens mostra el resultat. Podem modificar quantes vegades vulguem. i des del menu File podrem guardar la consulta, cosa que farem per a tots els exercicis del tema: Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4. Client DBeaver: utilitzaci\u00f3"},{"location":"BD_PostgreSQL_DQL/4_la_clusula_where/","text":"4. La cl\u00e0usula WHERE Ens servir\u00e0 per establir filtres. Nom\u00e9s eixiran les files que satisfacen la condici\u00f3 del filtre. Sintaxi SELECT <columnes> FROM <taules> WHERE <condici\u00f3>; La condici\u00f3 podr\u00e0 ser una o m\u00e9s d'una, unides en aquest cas pels operadors l\u00f2gics AND , OR i NOT . Cada condici\u00f3 ser\u00e0 una comparaci\u00f3 entre expressions, on poden entrar columnes, constants, par\u00e0metres, funcions v\u00e0lides de PostgreSQL, ... unides per operadors aritm\u00e8tics. Els operadors que es poden utilitzar per a fer les comparacions s\u00f3n: Recordem per una altra banda com s'escriuen les constants: les constants num\u00e8riques van tal qual, sense cometes ni res (amb el punt decimal, i no coma decimal) les constants alfanum\u00e8riques (de text) van entre cometes simples les constants de data van entre cometes simples, i PostgreSQL ja far\u00e0 la conversi\u00f3 per \u00faltim el valur nul s'escriu NULL Exemples 1) Traure les comarques de la prov\u00edncia de Castell\u00f3 SELECT * FROM COMARQUES WHERE provincia = 'Castell\u00f3'; 2) Traure totes les poblacions que tenen de llengua el valenci\u00e0. SELECT * FROM POBLACIONS WHERE llengua = 'V'; 3) Traure les poblacions de la comarca de la Plana Alta de m\u00e9s de 300 metres d'altura SELECT * FROM POBLACIONS WHERE nom_c = 'Plana Alta' AND altura > 300; 4) Traure els instituts dels codis postals 12001, 12002 o 12003) SELECT * FROM INSTITUTS WHERE codpostal=12001 OR codpostal=12002 OR codpostal=12003; SELECT * FROM INSTITUTS WHERE codpostal >= 12001 AND codpostal <= 12003; SELECT * FROM INSTITUTS WHERE codpostal BETWEEN 12001 AND 12003; SELECT * FROM INSTITUTS WHERE codpostal IN (12001,12002,12003); 5) Traure els pobles de la comarca Plana d'Utiel (Tenim la dificultat de la cometa simple, que ens serveix sempre per a delimitar una constant alfanum\u00e8rica) La manera de solucionar-ho \u00e9s posar-la dues vegades SELECT * FROM POBLACIONS WHERE nom_c = 'Plana d''Utiel'; 6) Traure nom i prov\u00edncia dels pobles que comencen per G (el primer cognom) SELECT nom, nom_c FROM POBLACIONS WHERE nom LIKE 'G%'; 7) Traure les poblacions que estan a 40\u00ba 1' (i els segons que siguen) de latitud nord SELECT * FROM POBLACIONS WHERE latitud LIKE '40\u00ba01____N'; Hem posat els 40\u00ba i 1 minut. A continuaci\u00f3 hem posat exactament 4 car\u00e0cters, els que siga. Hem posat 4, que serien la cometa que assenyala els minuts, les 2 xifres dels segons i la doble cometa que assenyala els segons. Observeu com la cometa simple \u00e9s problem\u00e0tica, ja que \u00e9s la que serveix per a delimitar la constant alfanum\u00e8rica. Si volem posar-la, en la constant l'haurem de doblar (l'haurem de posar 2 vegades seguides) SELECT * FROM POBLACIONS WHERE latitud LIKE '40\u00ba01''__\"N'; 8) Traure totes les poblacions, el nom de les quals nom\u00e9s consta d'una paraula (no tindran espais en blanc). SELECT * FROM POBLACIONS WHERE nom NOT LIKE '% %'; 9) Traure els instituts que no tenen introdu\u00eft el numero del carrer. SELECT * FROM INSTITUTS WHERE numero IS NULL; Exercicis Ex_7 Traure els clients de la ciutat amb codi 12309 . Ex_8 Traure totes les factures del mes de mar\u00e7 de 2015 . Ex_9 Traure tots els articles de la categoria BjcOlimpia amb un stock entre 2 i 7 unitats. Ex_10 Traure tots els clients que no tenen introdu\u00eft el codi postal . Ex_11 Traure tots els articles amb el stock introdu\u00eft per\u00f2 que no tenen introdu\u00eft el stock m\u00ednim . Ex_12 Traure tots els clients , el primer cognom dels quals \u00e9s VILLALONGA . Ex_13.a Modificar l'anterior per a traure tots els que s\u00f3n VILLALONGA de primer o de segon cognom. Ex_13.b Modificar l'anterior per a traure tots els que no s\u00f3n VILLALONGA ni de primer ni de segon cognom. Ex_14 Traure els articles \" Pulsador \" (la descripci\u00f3 cont\u00e9 aquesta paraula), el preu dels quals oscila entre 2 i 4 \u20ac i dels quals tenim un stock estrictament major que el stock m\u00ednim . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4. La cl\u00e0usula WHERE"},{"location":"BD_PostgreSQL_DQL/4_la_clusula_where/#4-la-clausula-where","text":"Ens servir\u00e0 per establir filtres. Nom\u00e9s eixiran les files que satisfacen la condici\u00f3 del filtre. Sintaxi SELECT <columnes> FROM <taules> WHERE <condici\u00f3>; La condici\u00f3 podr\u00e0 ser una o m\u00e9s d'una, unides en aquest cas pels operadors l\u00f2gics AND , OR i NOT . Cada condici\u00f3 ser\u00e0 una comparaci\u00f3 entre expressions, on poden entrar columnes, constants, par\u00e0metres, funcions v\u00e0lides de PostgreSQL, ... unides per operadors aritm\u00e8tics. Els operadors que es poden utilitzar per a fer les comparacions s\u00f3n: Recordem per una altra banda com s'escriuen les constants: les constants num\u00e8riques van tal qual, sense cometes ni res (amb el punt decimal, i no coma decimal) les constants alfanum\u00e8riques (de text) van entre cometes simples les constants de data van entre cometes simples, i PostgreSQL ja far\u00e0 la conversi\u00f3 per \u00faltim el valur nul s'escriu NULL Exemples 1) Traure les comarques de la prov\u00edncia de Castell\u00f3 SELECT * FROM COMARQUES WHERE provincia = 'Castell\u00f3'; 2) Traure totes les poblacions que tenen de llengua el valenci\u00e0. SELECT * FROM POBLACIONS WHERE llengua = 'V'; 3) Traure les poblacions de la comarca de la Plana Alta de m\u00e9s de 300 metres d'altura SELECT * FROM POBLACIONS WHERE nom_c = 'Plana Alta' AND altura > 300; 4) Traure els instituts dels codis postals 12001, 12002 o 12003) SELECT * FROM INSTITUTS WHERE codpostal=12001 OR codpostal=12002 OR codpostal=12003; SELECT * FROM INSTITUTS WHERE codpostal >= 12001 AND codpostal <= 12003; SELECT * FROM INSTITUTS WHERE codpostal BETWEEN 12001 AND 12003; SELECT * FROM INSTITUTS WHERE codpostal IN (12001,12002,12003); 5) Traure els pobles de la comarca Plana d'Utiel (Tenim la dificultat de la cometa simple, que ens serveix sempre per a delimitar una constant alfanum\u00e8rica) La manera de solucionar-ho \u00e9s posar-la dues vegades SELECT * FROM POBLACIONS WHERE nom_c = 'Plana d''Utiel'; 6) Traure nom i prov\u00edncia dels pobles que comencen per G (el primer cognom) SELECT nom, nom_c FROM POBLACIONS WHERE nom LIKE 'G%'; 7) Traure les poblacions que estan a 40\u00ba 1' (i els segons que siguen) de latitud nord SELECT * FROM POBLACIONS WHERE latitud LIKE '40\u00ba01____N'; Hem posat els 40\u00ba i 1 minut. A continuaci\u00f3 hem posat exactament 4 car\u00e0cters, els que siga. Hem posat 4, que serien la cometa que assenyala els minuts, les 2 xifres dels segons i la doble cometa que assenyala els segons. Observeu com la cometa simple \u00e9s problem\u00e0tica, ja que \u00e9s la que serveix per a delimitar la constant alfanum\u00e8rica. Si volem posar-la, en la constant l'haurem de doblar (l'haurem de posar 2 vegades seguides) SELECT * FROM POBLACIONS WHERE latitud LIKE '40\u00ba01''__\"N'; 8) Traure totes les poblacions, el nom de les quals nom\u00e9s consta d'una paraula (no tindran espais en blanc). SELECT * FROM POBLACIONS WHERE nom NOT LIKE '% %'; 9) Traure els instituts que no tenen introdu\u00eft el numero del carrer. SELECT * FROM INSTITUTS WHERE numero IS NULL;","title":"4. La cl\u00e0usula WHERE"},{"location":"BD_PostgreSQL_DQL/4_la_clusula_where/#exercicis","text":"Ex_7 Traure els clients de la ciutat amb codi 12309 . Ex_8 Traure totes les factures del mes de mar\u00e7 de 2015 . Ex_9 Traure tots els articles de la categoria BjcOlimpia amb un stock entre 2 i 7 unitats. Ex_10 Traure tots els clients que no tenen introdu\u00eft el codi postal . Ex_11 Traure tots els articles amb el stock introdu\u00eft per\u00f2 que no tenen introdu\u00eft el stock m\u00ednim . Ex_12 Traure tots els clients , el primer cognom dels quals \u00e9s VILLALONGA . Ex_13.a Modificar l'anterior per a traure tots els que s\u00f3n VILLALONGA de primer o de segon cognom. Ex_13.b Modificar l'anterior per a traure tots els que no s\u00f3n VILLALONGA ni de primer ni de segon cognom. Ex_14 Traure els articles \" Pulsador \" (la descripci\u00f3 cont\u00e9 aquesta paraula), el preu dels quals oscila entre 2 i 4 \u20ac i dels quals tenim un stock estrictament major que el stock m\u00ednim . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/5_funcions_dagregat/","text":"5. Funcions d'agregat Les funcions d'agregat , o funcions de domini agregat, s\u00f3n aquelles que trauen un resultat a partir dels valors d'un determinat camp en un conjunt de files. Aix\u00ed tindrem una funci\u00f3 per a sumar els valors d'una columna, o comptar -los, o traure la mitjana , o el m\u00e0xim , ... Actuaran sobre un conjunt de files determinat, que en principi suposarem que \u00e9s tota la taula (totes les files de la taula). En la seg\u00fcent pregunta, veurem que el conjunt de files sobre el qual es calcula una funci\u00f3 d'agregat, el podrem canviar amb la cl\u00e0usula GROUP BY . Sintaxi COUNT ( | ) * : compta el n\u00famero de files; si es posa una columna o expressi\u00f3, no es comptaran els valors nuls. * SUM ( ) * : torna la suma de la columna o expressi\u00f3 especificada. Ignora els valors nuls. * AVG ( ) * : calcula la mitjana aritm\u00e8tica de la columna o expressi\u00f3 especificada. Ignora els valors nuls. * VAR_SAMP ( ) * : calcula la vari\u00e0ncia d'una mostra a partir de la columna o expressi\u00f3 especificada. * STDDEV ( ) * : desviaci\u00f3 t\u00edpica d'una mostra. * MAX ( ) * : calcula el m\u00e0xim. * MIN ( ) * : calcula el m\u00ednim. Per exemple, si volem saber el nombre d'Instituts: SELECT COUNT(*) AS \"Nombre d'Instituts\" FROM INSTITUTS; Nota \u00c9s interessant la utilitzaci\u00f3 d'\u00e0lias, per a que no apareguen cap\u00e7aleres com count Exemples 1) Comptar el nombre total de pobles. SELECT Count(*) FROM POBLACIONS; 2) Comptar el nombre de poblacions de la Plana Alta . SELECT Count(*) FROM POBLACIONS WHERE nom_c = 'Plana Alta'; 3) Calcular la mitjana d'habitants dels pobles de la Plana Alta i Plana Baixa . SELECT AVG(poblacio) FROM POBLACIONS WHERE nom_c = 'Plana Alta' OR nom_c = 'Plana Baixa' 4) Calcular la mitjana de densitat de les poblacions. La densitat es calcula com el n\u00famero d'habitants dividit per l'extensi\u00f3. SELECT AVG(poblacio/extensio) FROM POBLACIONS; 5) Calcular l'altura m\u00e0xima i m\u00ednima de tots els pobles. SELECT MAX(altura), MIN(altura) FROM POBLACIONS Exercicis Ex_15 Comptar el nombre de clients que tenen el codi postal nul . Ex_16 Comptar el n\u00famero de vegades que l'article L76104 entra en les l\u00ednies de factura, i el n\u00famero total d'unitats venudes d'aquest article. Nom\u00e9s us fa falta la taula LINIA_FAC. Ex_17 Traure la mitjana del stock dels articles. Ex_18 Modificar l'anterior per a tenir en compte els valors nuls, com si foren 0 . Us vindr\u00e0 b\u00e9 la funci\u00f3 COALESCE que converteix els nuls del primer par\u00e0metre al valor donat com a segon par\u00e0metre (si \u00e9s diferent de nul, deixa igual el valor). Per tant l'heu d'utilitzar d'aquesta manera: COALESCE(stock,0) Ex_19 Comptar quantes factures t\u00e9 el client 375 Ex_20 Calcular el descompte m\u00e0xim , el m\u00ednim i el descompte mitj\u00e0 de les factures . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"5. Funcions d'agregat"},{"location":"BD_PostgreSQL_DQL/5_funcions_dagregat/#5-funcions-dagregat","text":"Les funcions d'agregat , o funcions de domini agregat, s\u00f3n aquelles que trauen un resultat a partir dels valors d'un determinat camp en un conjunt de files. Aix\u00ed tindrem una funci\u00f3 per a sumar els valors d'una columna, o comptar -los, o traure la mitjana , o el m\u00e0xim , ... Actuaran sobre un conjunt de files determinat, que en principi suposarem que \u00e9s tota la taula (totes les files de la taula). En la seg\u00fcent pregunta, veurem que el conjunt de files sobre el qual es calcula una funci\u00f3 d'agregat, el podrem canviar amb la cl\u00e0usula GROUP BY . Sintaxi COUNT ( | ) * : compta el n\u00famero de files; si es posa una columna o expressi\u00f3, no es comptaran els valors nuls. * SUM ( ) * : torna la suma de la columna o expressi\u00f3 especificada. Ignora els valors nuls. * AVG ( ) * : calcula la mitjana aritm\u00e8tica de la columna o expressi\u00f3 especificada. Ignora els valors nuls. * VAR_SAMP ( ) * : calcula la vari\u00e0ncia d'una mostra a partir de la columna o expressi\u00f3 especificada. * STDDEV ( ) * : desviaci\u00f3 t\u00edpica d'una mostra. * MAX ( ) * : calcula el m\u00e0xim. * MIN ( ) * : calcula el m\u00ednim. Per exemple, si volem saber el nombre d'Instituts: SELECT COUNT(*) AS \"Nombre d'Instituts\" FROM INSTITUTS; Nota \u00c9s interessant la utilitzaci\u00f3 d'\u00e0lias, per a que no apareguen cap\u00e7aleres com count Exemples 1) Comptar el nombre total de pobles. SELECT Count(*) FROM POBLACIONS; 2) Comptar el nombre de poblacions de la Plana Alta . SELECT Count(*) FROM POBLACIONS WHERE nom_c = 'Plana Alta'; 3) Calcular la mitjana d'habitants dels pobles de la Plana Alta i Plana Baixa . SELECT AVG(poblacio) FROM POBLACIONS WHERE nom_c = 'Plana Alta' OR nom_c = 'Plana Baixa' 4) Calcular la mitjana de densitat de les poblacions. La densitat es calcula com el n\u00famero d'habitants dividit per l'extensi\u00f3. SELECT AVG(poblacio/extensio) FROM POBLACIONS; 5) Calcular l'altura m\u00e0xima i m\u00ednima de tots els pobles. SELECT MAX(altura), MIN(altura) FROM POBLACIONS","title":"5. Funcions d'agregat"},{"location":"BD_PostgreSQL_DQL/5_funcions_dagregat/#exercicis","text":"Ex_15 Comptar el nombre de clients que tenen el codi postal nul . Ex_16 Comptar el n\u00famero de vegades que l'article L76104 entra en les l\u00ednies de factura, i el n\u00famero total d'unitats venudes d'aquest article. Nom\u00e9s us fa falta la taula LINIA_FAC. Ex_17 Traure la mitjana del stock dels articles. Ex_18 Modificar l'anterior per a tenir en compte els valors nuls, com si foren 0 . Us vindr\u00e0 b\u00e9 la funci\u00f3 COALESCE que converteix els nuls del primer par\u00e0metre al valor donat com a segon par\u00e0metre (si \u00e9s diferent de nul, deixa igual el valor). Per tant l'heu d'utilitzar d'aquesta manera: COALESCE(stock,0) Ex_19 Comptar quantes factures t\u00e9 el client 375 Ex_20 Calcular el descompte m\u00e0xim , el m\u00ednim i el descompte mitj\u00e0 de les factures . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/6_la_clusula_group_by/","text":"6. La cl\u00e0usula GROUP BY Agrupa totes les files amb valors iguals d'una o d'unes columnes Sintaxi SELECT <columnes> FROM <taules> GROUP BY <columnes> Per cada fila amb valors iguals de les columnes de la cl\u00e0usula GROUP BY , en trau nom\u00e9s una, \u00e9s a dir, les agrupa. Les funcions d'agregat agafen tot el seu sentit i pot\u00e8ncia combinades amb el GROUP BY : tornaran un valor per cada grup. Aix\u00ed, per exemple, aquesta sent\u00e8ncia traur\u00e0 quantes poblacions hi ha en cada comarca: SELECT COUNT(*) FROM POBLACIONS GROUP BY nom_c Si volem excloure files per a que no entren en les agrupacions, ho farem per mig de la cl\u00e0usula WHERE . En aquest exemple ens aprofitem del codi de municipi, que en el cas dels municipis de la prov\u00edncia de Castell\u00f3 \u00e9s 12000 i pico. SELECT COUNT(*) FROM POBLACIONS WHERE cod_m >= 12000 and cod_m < 13000 GROUP BY nom_c Quan tenim agrupacions de files, b\u00e9 perqu\u00e8 utilitzem la cl\u00e0usula GROUP BY, b\u00e9 perqu\u00e8 entre les columnes que es trien en el SELECT hi ha alguna funci\u00f3 d'agregat, o les dues coses a l'hora, es poden cometre errors amb una relativa facilitat. Quan hi ha una agrupaci\u00f3 totes les columnes que seleccionem amb el SELECT hauran d'estar en el GROUP BY, o b\u00e9 estar dins d'una funci\u00f3 d'agregat . En cas contrari ens donar\u00e0 error. Per exemple, aquesta consulta funciona b\u00e9, i de fet \u00e9s millor consulta que les d'abans, ja que ens diu la comarca i el numero de pobles que t\u00e9 cadascuna: SELECT nom_c, COUNT(*) FROM POBLACIONS GROUP BY nom_c Per\u00f2 aquesta no: SELECT nom_c, COUNT(*), cod_m FROM POBLACIONS GROUP BY nom_c \u00c9s sint\u00e0cticament incorrecta, i a banda no t\u00e9 sentit: si agrupem tots els pobles de la mateixa comarca \u00bfcom hem de poder traure despr\u00e9s el codi del municipi de cada poble?. Com \u00e9s relativament f\u00e0cil cometre aquest error, haurem d'identificar aquest error, per a poder solucionar-lo. Per exemple, aquesta consulta ens d\u00f3na la poblaci\u00f3 m\u00e9s alta de cada comarca: SELECT nom_c, MAX(altura) FROM POBLACIONS GROUP BY nom_c Per\u00f2 si intent\u00e0rem traure tamb\u00e9 el nom de la poblaci\u00f3 m\u00e9s alta de cada comarca: SELECT nom_c, MAX(altura), nom FROM POBLACIONS GROUP BY nom_c ens donaria el seg\u00fcent error: Hem d'aprendre a identificar aquest error, i solucionar-lo. En aquest cas el solucionarem llevant el camp Nom . La sent\u00e8ncia per a poder traure el nom de la poblaci\u00f3 m\u00e9s alta de cada comarca \u00e9s complicada, i encara no podem fer- la. Exemples 1) Comptar el nombre d'instituts de cada poblaci\u00f3. SELECT cod_m, COUNT(*) FROM INSTITUTS GROUP BY cod_m 2) Comptar el nombre de comarques de cada prov\u00edncia. SELECT provincia, COUNT(*) FROM COMARQUES GROUP BY provincia 3) Calcular l'altura m\u00e0xima, m\u00ednima i l'altura mitjana de cada comarca. SELECT nom_c, MAX(altura), MIN(altura), AVG(altura) FROM POBLACIONS GROUP BY nom_c 4) Comptar el nombre d'instituts de cada poblaci\u00f3 i cada codi postal. SELECT cod_m, codpostal, COUNT(*) FROM INSTITUTS GROUP BY cod_m, codpostal Exercicis Ex_21 Comptar el n\u00famero de pobles de cada prov\u00edncia (\u00e9s suficient traure el codi de la prov\u00edncia i el n\u00famero de pobles). Ex_22 Comptar el nombre de clients en cada poble i codi postal. Ex_23 Comptar el n\u00famero de factures de cada venedor a cada client. Ex_24 Comptar el n\u00famero de factures de cada trimestre. Per a poder traure el trimestre i agrupar per ell (ens val el n\u00famero de trimestre, que va del 1 al 4), podem utilitzar la funci\u00f3 TO_CHAR(data,'Q') . Ex_25 Calcular quantes vegades s'ha venut un article, la suma d'unitats venudes, la quantitat m\u00e0xima i la quantitat m\u00ednima. Ex_26 Comptar el n\u00famero d'articles de cada categoria i el preu mitj\u00e0. Ex_27 Calcular el total de cada factura, sense aplicar descomptes ni IVA. Nom\u00e9s ens far\u00e0 falta la taula LINIES_FAC , i consistir\u00e0 en agrupar per cada num_f per a calcular la suma del preu multiplicat per la quantitat . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"6. La cl\u00e0usula GROUP BY"},{"location":"BD_PostgreSQL_DQL/6_la_clusula_group_by/#6-la-clausula-group-by","text":"Agrupa totes les files amb valors iguals d'una o d'unes columnes Sintaxi SELECT <columnes> FROM <taules> GROUP BY <columnes> Per cada fila amb valors iguals de les columnes de la cl\u00e0usula GROUP BY , en trau nom\u00e9s una, \u00e9s a dir, les agrupa. Les funcions d'agregat agafen tot el seu sentit i pot\u00e8ncia combinades amb el GROUP BY : tornaran un valor per cada grup. Aix\u00ed, per exemple, aquesta sent\u00e8ncia traur\u00e0 quantes poblacions hi ha en cada comarca: SELECT COUNT(*) FROM POBLACIONS GROUP BY nom_c Si volem excloure files per a que no entren en les agrupacions, ho farem per mig de la cl\u00e0usula WHERE . En aquest exemple ens aprofitem del codi de municipi, que en el cas dels municipis de la prov\u00edncia de Castell\u00f3 \u00e9s 12000 i pico. SELECT COUNT(*) FROM POBLACIONS WHERE cod_m >= 12000 and cod_m < 13000 GROUP BY nom_c Quan tenim agrupacions de files, b\u00e9 perqu\u00e8 utilitzem la cl\u00e0usula GROUP BY, b\u00e9 perqu\u00e8 entre les columnes que es trien en el SELECT hi ha alguna funci\u00f3 d'agregat, o les dues coses a l'hora, es poden cometre errors amb una relativa facilitat. Quan hi ha una agrupaci\u00f3 totes les columnes que seleccionem amb el SELECT hauran d'estar en el GROUP BY, o b\u00e9 estar dins d'una funci\u00f3 d'agregat . En cas contrari ens donar\u00e0 error. Per exemple, aquesta consulta funciona b\u00e9, i de fet \u00e9s millor consulta que les d'abans, ja que ens diu la comarca i el numero de pobles que t\u00e9 cadascuna: SELECT nom_c, COUNT(*) FROM POBLACIONS GROUP BY nom_c Per\u00f2 aquesta no: SELECT nom_c, COUNT(*), cod_m FROM POBLACIONS GROUP BY nom_c \u00c9s sint\u00e0cticament incorrecta, i a banda no t\u00e9 sentit: si agrupem tots els pobles de la mateixa comarca \u00bfcom hem de poder traure despr\u00e9s el codi del municipi de cada poble?. Com \u00e9s relativament f\u00e0cil cometre aquest error, haurem d'identificar aquest error, per a poder solucionar-lo. Per exemple, aquesta consulta ens d\u00f3na la poblaci\u00f3 m\u00e9s alta de cada comarca: SELECT nom_c, MAX(altura) FROM POBLACIONS GROUP BY nom_c Per\u00f2 si intent\u00e0rem traure tamb\u00e9 el nom de la poblaci\u00f3 m\u00e9s alta de cada comarca: SELECT nom_c, MAX(altura), nom FROM POBLACIONS GROUP BY nom_c ens donaria el seg\u00fcent error: Hem d'aprendre a identificar aquest error, i solucionar-lo. En aquest cas el solucionarem llevant el camp Nom . La sent\u00e8ncia per a poder traure el nom de la poblaci\u00f3 m\u00e9s alta de cada comarca \u00e9s complicada, i encara no podem fer- la. Exemples 1) Comptar el nombre d'instituts de cada poblaci\u00f3. SELECT cod_m, COUNT(*) FROM INSTITUTS GROUP BY cod_m 2) Comptar el nombre de comarques de cada prov\u00edncia. SELECT provincia, COUNT(*) FROM COMARQUES GROUP BY provincia 3) Calcular l'altura m\u00e0xima, m\u00ednima i l'altura mitjana de cada comarca. SELECT nom_c, MAX(altura), MIN(altura), AVG(altura) FROM POBLACIONS GROUP BY nom_c 4) Comptar el nombre d'instituts de cada poblaci\u00f3 i cada codi postal. SELECT cod_m, codpostal, COUNT(*) FROM INSTITUTS GROUP BY cod_m, codpostal","title":"6. La cl\u00e0usula GROUP BY"},{"location":"BD_PostgreSQL_DQL/6_la_clusula_group_by/#exercicis","text":"Ex_21 Comptar el n\u00famero de pobles de cada prov\u00edncia (\u00e9s suficient traure el codi de la prov\u00edncia i el n\u00famero de pobles). Ex_22 Comptar el nombre de clients en cada poble i codi postal. Ex_23 Comptar el n\u00famero de factures de cada venedor a cada client. Ex_24 Comptar el n\u00famero de factures de cada trimestre. Per a poder traure el trimestre i agrupar per ell (ens val el n\u00famero de trimestre, que va del 1 al 4), podem utilitzar la funci\u00f3 TO_CHAR(data,'Q') . Ex_25 Calcular quantes vegades s'ha venut un article, la suma d'unitats venudes, la quantitat m\u00e0xima i la quantitat m\u00ednima. Ex_26 Comptar el n\u00famero d'articles de cada categoria i el preu mitj\u00e0. Ex_27 Calcular el total de cada factura, sense aplicar descomptes ni IVA. Nom\u00e9s ens far\u00e0 falta la taula LINIES_FAC , i consistir\u00e0 en agrupar per cada num_f per a calcular la suma del preu multiplicat per la quantitat . Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/6_operadors/","text":"4.1 Operadors Els operadors que es gasten en el SQL de PostgreSQL s\u00f3n molt\u00edssims. Cada tipus de dades t\u00e9 una s\u00e8rie d'operadors, i el mateix operador, aplicat a tipus distints pot fer coses diferents. Es poden veure tots els operadors en la taula PG_OPERATOR , on tindrem el nom de l'operador, els tipus de dades dels operands i del resultat i el procediment que implementa l'operador. Ac\u00ed tenim una vista d'aquesta taula, encara que hi ha tant\u00edssims operadors que mareja i tot (els que estan repetits \u00e9s per a especificar l'actuaci\u00f3 sobre operands de diferents tipus). Podr\u00edem fins i tot definir els nostres operadors, amb la sent\u00e8ncia CREATE OPERATOR , on definir\u00edem el tipus de l'operador de l'esquerra, el de la dreta, la funci\u00f3 que implementa l'operador, ... Ho intentarem en el tema seg\u00fcent, quan ja sapiguem crear funcions. No farem un rep\u00e0s extens de tots els operadors. Nom\u00e9s els m\u00e9s habituals, i algun d'un tipus de dades especial. Els tipus de dades els veurem en la tercera part d'aquest tema, quan les sent\u00e8ncies de creaci\u00f3 de taules. Per tant, fixeu-vos sobretot en els opradors aritm\u00e8tics , de cadena i de comparaci\u00f3 . Operadors aritm\u00e8tics + Suma - Resta * Multiplicaci\u00f3 / Divisi\u00f3 ^ Exponenciaci\u00f3 |/ Arrel quadrada ! Factorial % M\u00f2dul (rest de la divisi\u00f3) Exemples SELECT |/16; SELECT 5 ^ 3; SELECT 5!; Operadors de cadena || Concatenaci\u00f3 Exemples SELECT 'Data i hora actual: ' || Now(); Operadors de comparaci\u00f3 = Igual < > Distint != Distint > Major > = Major o igual < Menor < = Menor o igual S'utilitzen principalment en les condicions. Tornen sempre un valor boole\u00e0 (true o false) Operadors conversor de tipus ::tipus Servir\u00e0 per a convertir alguna dada a algun tipus de dades. Aix\u00ed, per exemple, '25-4-2012'::date estem convertint una cadena de text en una dada de tipus date. '(0,0)'::point estem convertint el text a un punt. La forma utilitzada en els exemples anteriors \u00e9s una forma molt habitual de posar les constants d'un determinat tipus: la posem com a cadena de car\u00e0cters (entre cometes) i despr\u00e9s la convertim. L'\u00fanica restricci\u00f3 ser\u00e0 que PostgreSQL \"entenga\" el que hi ha entre cometes per fer la conversi\u00f3. Per veure que realment hi ha un canvi ens aprofitem de DBeaver que diu de quin tipus \u00e9s un camp, si pot. Observeu que en el primer camp no hem posat m\u00e9s que una tira de car\u00e0cters, per\u00f2 en el segon intentem reconvertir aquesta mateixa tira de car\u00e0cters al tipus POINT. En el resultat s'observa com ha ent\u00e9s que el tipus de la dada \u00e9s POINT. Tamb\u00e9 ens serviria la funci\u00f3 point ('(0,0)') Operadors Geom\u00e8trics Operador Descripci\u00f3 Utilitzaci\u00f3 <-> Dist\u00e0ncia (han de ser del mateix tipus) point '(1,0)' <-> point '(3,0)' <@ Est\u00e0 contingut en? '(1,1)'::point @ '((0,0),(2,2))'::box @> Cont\u00e9? box '((0,0),(2,2))' @> point '(1,1)' La llista d'operadors \u00e9s molt m\u00e9s llarga, per\u00f2 ac\u00ed nom\u00e9s volem mostrar-ne algun a mode il\u00b7lustratiu. Podem fer comprovacions d'aquest tipus: SELECT '(0,0)'::point <-> '(3,4)'::point; que ens donar\u00e0 la dist\u00e0ncia entre el punt (0,0) i el punt (3,4) . Aquesta dist\u00e0ncia ha de ser 5. SELECT '(1,1)'::point <@ '((0,0),2)'::circle; que ens dir\u00e0 si el punt (1,1) est\u00e0 dins del cercle amb origen (0,0) i radi 2 . Com que s\u00ed que est\u00e0 tornar\u00e0 el valor true (vertader). Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4.1. Operadors"},{"location":"BD_PostgreSQL_DQL/6_operadors/#41-operadors","text":"Els operadors que es gasten en el SQL de PostgreSQL s\u00f3n molt\u00edssims. Cada tipus de dades t\u00e9 una s\u00e8rie d'operadors, i el mateix operador, aplicat a tipus distints pot fer coses diferents. Es poden veure tots els operadors en la taula PG_OPERATOR , on tindrem el nom de l'operador, els tipus de dades dels operands i del resultat i el procediment que implementa l'operador. Ac\u00ed tenim una vista d'aquesta taula, encara que hi ha tant\u00edssims operadors que mareja i tot (els que estan repetits \u00e9s per a especificar l'actuaci\u00f3 sobre operands de diferents tipus). Podr\u00edem fins i tot definir els nostres operadors, amb la sent\u00e8ncia CREATE OPERATOR , on definir\u00edem el tipus de l'operador de l'esquerra, el de la dreta, la funci\u00f3 que implementa l'operador, ... Ho intentarem en el tema seg\u00fcent, quan ja sapiguem crear funcions. No farem un rep\u00e0s extens de tots els operadors. Nom\u00e9s els m\u00e9s habituals, i algun d'un tipus de dades especial. Els tipus de dades els veurem en la tercera part d'aquest tema, quan les sent\u00e8ncies de creaci\u00f3 de taules. Per tant, fixeu-vos sobretot en els opradors aritm\u00e8tics , de cadena i de comparaci\u00f3 . Operadors aritm\u00e8tics + Suma - Resta * Multiplicaci\u00f3 / Divisi\u00f3 ^ Exponenciaci\u00f3 |/ Arrel quadrada ! Factorial % M\u00f2dul (rest de la divisi\u00f3) Exemples SELECT |/16; SELECT 5 ^ 3; SELECT 5!; Operadors de cadena || Concatenaci\u00f3 Exemples SELECT 'Data i hora actual: ' || Now(); Operadors de comparaci\u00f3 = Igual < > Distint != Distint > Major > = Major o igual < Menor < = Menor o igual S'utilitzen principalment en les condicions. Tornen sempre un valor boole\u00e0 (true o false) Operadors conversor de tipus ::tipus Servir\u00e0 per a convertir alguna dada a algun tipus de dades. Aix\u00ed, per exemple, '25-4-2012'::date estem convertint una cadena de text en una dada de tipus date. '(0,0)'::point estem convertint el text a un punt. La forma utilitzada en els exemples anteriors \u00e9s una forma molt habitual de posar les constants d'un determinat tipus: la posem com a cadena de car\u00e0cters (entre cometes) i despr\u00e9s la convertim. L'\u00fanica restricci\u00f3 ser\u00e0 que PostgreSQL \"entenga\" el que hi ha entre cometes per fer la conversi\u00f3. Per veure que realment hi ha un canvi ens aprofitem de DBeaver que diu de quin tipus \u00e9s un camp, si pot. Observeu que en el primer camp no hem posat m\u00e9s que una tira de car\u00e0cters, per\u00f2 en el segon intentem reconvertir aquesta mateixa tira de car\u00e0cters al tipus POINT. En el resultat s'observa com ha ent\u00e9s que el tipus de la dada \u00e9s POINT. Tamb\u00e9 ens serviria la funci\u00f3 point ('(0,0)') Operadors Geom\u00e8trics Operador Descripci\u00f3 Utilitzaci\u00f3 <-> Dist\u00e0ncia (han de ser del mateix tipus) point '(1,0)' <-> point '(3,0)' <@ Est\u00e0 contingut en? '(1,1)'::point @ '((0,0),(2,2))'::box @> Cont\u00e9? box '((0,0),(2,2))' @> point '(1,1)' La llista d'operadors \u00e9s molt m\u00e9s llarga, per\u00f2 ac\u00ed nom\u00e9s volem mostrar-ne algun a mode il\u00b7lustratiu. Podem fer comprovacions d'aquest tipus: SELECT '(0,0)'::point <-> '(3,4)'::point; que ens donar\u00e0 la dist\u00e0ncia entre el punt (0,0) i el punt (3,4) . Aquesta dist\u00e0ncia ha de ser 5. SELECT '(1,1)'::point <@ '((0,0),2)'::circle; que ens dir\u00e0 si el punt (1,1) est\u00e0 dins del cercle amb origen (0,0) i radi 2 . Com que s\u00ed que est\u00e0 tornar\u00e0 el valor true (vertader). Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4.1 Operadors"},{"location":"BD_PostgreSQL_DQL/7_funcions/","text":"4.2 Funcions Com veurem un poc m\u00e9s avant, en les sent\u00e8ncies SQL, a banda de columnes i valors constants, podrem utilitzar funcions. PostgreSQL t\u00e9 moltes funcions ja creades. Farem un recull de les funcions m\u00e9s importants de PostgreSQL, d'entre la multitud de funcions que existeixen. Les agruparem per categories. Evidentment aquest recull no \u00e9s per aprendre'l de mem\u00f2ria, sin\u00f3 que servir\u00e0 de consulta. Funcions num\u00e8riques Funci\u00f3 Explicaci\u00f3 Funci\u00f3 Explicaci\u00f3 ABS(n) Valor absolut de n. LOG(m,n) Logaritme, base m, de n ACOS(n) Arccosinus de n (invers del cosinus) MOD(m,n) La resta de la divisi\u00f3 entre m i n ASIN(n) Arcsinus de n (invers de sinus) POWER(m,n) m elevat a n ATAN(n) Arctangent de n (invers de la tangent) RANDOM() n\u00famero aleatori entre 0 i 1 CEIL(n) Enter immediatament superior o igual a n Round(n,[m]) n arrodonit a m xifres decimals (per defecte 0) COS(n) Cosinus de n. SIN(n) Sinus de n EXP(n) Exponencial de n (en) SQRT(n) Arrel quadrada de n FLOOR(n) Enter immediatament inferior o igual a n TAN(n) Tangent de n LN(n) Logaritme neperi\u00e0 de n Trunc(n,[m]) n truncat a m xifres decimals (per defecte 0) Per exemple, podr\u00edem simular el llan\u00e7ament d'un dau d'aquesta manera: SELECT TRUNC(RANDOM()*6+1); Funcions de car\u00e0cters Funci\u00f3 Explicaci\u00f3 ASCII(c) Torna el codi ASCII corresponent al car\u00e0cter c REPLACE(c1,c2,c3) Reempla\u00e7a en c1 cada ocurr\u00e8ncia de c2 per c3 CHR(n) Torna el car\u00e0cter amb codi ASCII n. RPAD(c1,n[c2]) Torna c1 reomplida per la dreta fins n car\u00e0cters amb la cadena c2 CONCAT(c1,c2) Concatena les dues cadenes (equivalent a l'operador INITCAP(c1) Torna la cadena amb la primera lletra de cada paraula en maj\u00fascules, i les altres en min\u00fascules STRPOS(s,s1) Busca la primera ocurr\u00e8ncia de la subcadena s1 dins de la cadena s LENGTH(c1) Llarg\u00e0ria de la cadena. Si c1 \u00e9s de tipus CHAR, inclour\u00e0 tots els espais en blanc del final. SUBSTR(c1,m[,n]) Torna una subcadena de c1 que comen\u00e7a en el car\u00e0cter m i consta de n car\u00e0cters (per defecte fins el final) LPAD(c1,n[c2]) Torna c1 reomplida per l\u2019esquerra fins n car\u00e0cters amb la cadena c2 TRANSLATE(c1,c2,c3) Torna c1 amb cada car\u00e0cter de c2 substitu\u00eft pel corresponent (en ordre) de c3. LTRIM(c1[,set]) Retalla per l\u2019esquerra mentre troba la cadena set (per defecte blancs) LOWER(c1) Torna la cadena en min\u00fascules UPPER(c1) Torna la cadena en maj\u00fascules Per exemple, traurem els graus de la latitud de les poblacions. Haurem d'agafar els 2 primers car\u00e0cters (els de l'esquerra). SELECT nom , latitud , SUBSTR(latitud,1,2) FROM POBLACIONS; A\u00e7\u00f2 ho podr\u00edem millorar, ja que d'aquesta manera obliguem a que siguen sempre dos car\u00e0cters, els graus. De forma m\u00e9s gen\u00e8rica, els graus \u00e9s el que va davant del s\u00edmbol \u00ba . Per tant el que podem fer \u00e9s buscar aquest s\u00edmbol i traure els de davant (des del primer fins a l'anterior a ell) SELECT nom , latitud , SUBSTR(latitud,1,STRPOS(latitud,'\u00ba')-1) FROM POBLACIONS; Per agafar els minuts de forma senzilla seria traure els car\u00e0cters 4t i 5\u00e8, \u00e9s a dir, 2 car\u00e0cters a partir del 4. SELECT nom , latitud , SUBSTR(latitud,4,2) FROM POBLACIONS; Per\u00f2 de forma m\u00e9s gen\u00e8rica (per si no s'han posat 0 no significatius), haurem de traure des de despr\u00e9s del s\u00edmbol \u00ba fins al car\u00e0ctar anterior a ' (la cometa) que assenyala els minuts. Tenim a m\u00e9s la dificultat afegida que la cometa justament \u00e9s la manera d'especificar un text en SQL. Haurem de posar dos cometes per a escapar, i com que \u00e9s un text va entre cometes. Resultat: 4 cometes. SELECT nom , latitud , SUBSTR(latitud,STRPOS(latitud,'\u00ba')+1,STRPOS(latitud,'''')-STRPOS(latitud,'\u00ba')-1) FROM POBLACIONS; I el mateix far\u00edem per als segons, (entre la cometa simple i la doble). Aquesta sent\u00e8ncia resumeix l'anterior, separant graus, minuts i segons. SELECT nom, latitud, SUBSTR(latitud,1,STRPOS(latitud,'\u00ba')-1), SUBSTR(latitud,STRPOS(latitud,'\u00ba')+1,STRPOS(latitud,'''')-STRPOS(latitud,'\u00ba')-1), SUBSTR(latitud,STRPOS(latitud,'''')+1,STRPOS(latitud,'\"')-STRPOS(latitud,'''')-1) FROM POBLACIONS; Funcions de data Funci\u00f3 Explicaci\u00f3 NOW() (CURRENT_TIMESTAMP) Torna la data-hora actual, amb la difer\u00e8ncia d'hores respecte la GMT LOCALTIMESTAMP Igual que l'anterior, per\u00f2 sense la difer\u00e8ncia de la GMT CURRENT_DATE Torna la data actual CURRENT_TIME Torna l'hora actual (amb difer\u00e8ncia GMT) LOCALTIME Torna l'hora actual (sense difer\u00e8ncia GMT) AGE(t) Torna la difer\u00e8ncia de la data actual i t AGE(t1,t2) Torna la difer\u00e8ncia entre t1 (posterior) i t2 (anterior) EXTRACT(camp FROM t) Trau el n\u00famero corresponent al camp (que pot ser year, month, day, hour, minute, second, millisecond, microsecond, dow (day of week), ... Per exemple, \u00bfquan de temps ha passat des de l'intent de cop d'estat? SELECT AGE('1981/02/23'::DATE); O un altre, \u00bfen quin any estem? SELECT EXTRACT(year FROM CURRENT_DATE); Funcions geom\u00e8triques Funci\u00f3 Explicaci\u00f3 Funci\u00f3 Explicaci\u00f3 AREA(o) \u00c0rea de l'objecte HEIGTH(r) Altura del rect\u00e0ngle CENTER(o) Centre de l'objecte RADIUS(c) Radi del cercle DIAMETER(c) Di\u00e0metre del cercle WIDTH(r) Ampl\u00e0ria del rect\u00e0ngle Per exemple, l'\u00e0rea d'un cercle: SELECT AREA('((5,5),2)'::CIRCLE); Funcions Funci\u00f3 Explicaci\u00f3 Exemple Resultat HOST(ip) Trau en format text l'adre\u00e7a IP HOST('192.168.2.15/24') 192.168.2.15 MASKLEN(ip) Trau el n\u00famero de bits de la m\u00e0scara MASKLEN('192.168.2.15/24') 24 SET_MASKLEN(ip,n) Posa el n\u00famero de bits de la m\u00e0scara als especificats SET_MASKLEN('192.168.2.15/24',16) 192.168.2.15/16 NETMASK(ip) Construeix la m\u00e0scara de xarxa NETMASK('192.168.2.15/24') 255.255.255.0 Funcions de conversi\u00f3 Serviran per a passar d'un tipus a un altre, on un d'ells ser\u00e0 el tipus de cadena (VARCHAR) Funci\u00f3 Explicaci\u00f3 TO_CHAR( data, format ) Converteix una data en una tira de car\u00e0cters, utilitzant el format especificat (es veur\u00e0 aquest format en la seg\u00fcent pregunta) TO_CHAR( n\u00famero, format ) Converteix un n\u00famero en una tira de car\u00e0cters TO_NUMBER( exp., format ) Converteix una tira de car\u00e0cters en un n\u00famero, suposant que estava en el format indicat TO_DATE( exp., format ) Converteix una tira de car\u00e0cters en un data TO_DATETIME( exp., format ) converteix una tira de car\u00e0cters en un data-hora 4.2.1 Formats de les dates Aquest tipus \u00e9s molt vers\u00e0til en quant al format, b\u00e9 siga per a la introducci\u00f3 de les dades, o el que \u00e9s m\u00e9s habitual, per a la seua presentaci\u00f3. S'haur\u00e0 d'utilitzar una funci\u00f3, TO_CHAR , que acceptar\u00e0 2 par\u00e0metres: el primer la data que es vol presentar, i el segon el format que volem. En el format indicarem per mig de determinats car\u00e0cters l'aspecte que volem. Per exemple, per a traure la data d'avui amb el format dia-mes-any, posar\u00edem: SELECT TO_CHAR( NOW(), 'DD-MM-YYYY'); El seg\u00fcent quadre resumeix aquestos car\u00e0cters, agrupat per categories: En principi els formats que tornen lletres ho estaran en angl\u00e8s, per\u00f2 despr\u00e9s veurem com canviar d'idioma. Exemples: Si ara f\u00f3ra 9/1/16 13:39 (en el servidor, no en la vostra m\u00e0quina), i f\u00e9rem SELECT TO_CHAR(NOW(),' format '); Format Eixida dd-mm-yy hh:mi 09-01-23 01:39 dd-mm-yy hh24:mi 09-01-16 13:39 dd-MON-yyy 09-JAN-023 dd-TMMON-yyy 09-ENE-023 (si el tingu\u00e9rem configurat en espanyol) Day, dd \"de\" month \"de\" yyyy Monday , 09 de january de 2023 de 2016 FMDay, dd \"de\" FMmonth \"de\" yyyy. Monday, 09 de january de 2023. TMDay, dd \"de\" TMmonth \"de\" yyyy. Lunes, 09 de enero de 2023. (si el tingu\u00e9rem configurat en espanyol) FMDy PM FMhh-FMmi-FMss Mon PM 1-39-00 TMDy PM TMhh-TMmi-TMss Lun PM 01-39-00 __ (si el tingu\u00e9rem configurat en espanyol) 4.2.2 Formats dels n\u00fameros Tamb\u00e9 podrem utilitzar la funci\u00f3 TO_CHAR per a donar l'aspecte que vulguem als n\u00fameros. En la seg\u00fcent taula tenim un resum amb els diferents s\u00edmbols, un comentari descriptiu de cada s\u00edmbol, i un exemple de format amb el resultat que donaria per a un determinat valor. La sent\u00e8ncia seria SELECT TO_CHAR( valor ,' format '); : Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4.2. Funcions"},{"location":"BD_PostgreSQL_DQL/7_funcions/#42-funcions","text":"Com veurem un poc m\u00e9s avant, en les sent\u00e8ncies SQL, a banda de columnes i valors constants, podrem utilitzar funcions. PostgreSQL t\u00e9 moltes funcions ja creades. Farem un recull de les funcions m\u00e9s importants de PostgreSQL, d'entre la multitud de funcions que existeixen. Les agruparem per categories. Evidentment aquest recull no \u00e9s per aprendre'l de mem\u00f2ria, sin\u00f3 que servir\u00e0 de consulta. Funcions num\u00e8riques Funci\u00f3 Explicaci\u00f3 Funci\u00f3 Explicaci\u00f3 ABS(n) Valor absolut de n. LOG(m,n) Logaritme, base m, de n ACOS(n) Arccosinus de n (invers del cosinus) MOD(m,n) La resta de la divisi\u00f3 entre m i n ASIN(n) Arcsinus de n (invers de sinus) POWER(m,n) m elevat a n ATAN(n) Arctangent de n (invers de la tangent) RANDOM() n\u00famero aleatori entre 0 i 1 CEIL(n) Enter immediatament superior o igual a n Round(n,[m]) n arrodonit a m xifres decimals (per defecte 0) COS(n) Cosinus de n. SIN(n) Sinus de n EXP(n) Exponencial de n (en) SQRT(n) Arrel quadrada de n FLOOR(n) Enter immediatament inferior o igual a n TAN(n) Tangent de n LN(n) Logaritme neperi\u00e0 de n Trunc(n,[m]) n truncat a m xifres decimals (per defecte 0) Per exemple, podr\u00edem simular el llan\u00e7ament d'un dau d'aquesta manera: SELECT TRUNC(RANDOM()*6+1); Funcions de car\u00e0cters Funci\u00f3 Explicaci\u00f3 ASCII(c) Torna el codi ASCII corresponent al car\u00e0cter c REPLACE(c1,c2,c3) Reempla\u00e7a en c1 cada ocurr\u00e8ncia de c2 per c3 CHR(n) Torna el car\u00e0cter amb codi ASCII n. RPAD(c1,n[c2]) Torna c1 reomplida per la dreta fins n car\u00e0cters amb la cadena c2 CONCAT(c1,c2) Concatena les dues cadenes (equivalent a l'operador INITCAP(c1) Torna la cadena amb la primera lletra de cada paraula en maj\u00fascules, i les altres en min\u00fascules STRPOS(s,s1) Busca la primera ocurr\u00e8ncia de la subcadena s1 dins de la cadena s LENGTH(c1) Llarg\u00e0ria de la cadena. Si c1 \u00e9s de tipus CHAR, inclour\u00e0 tots els espais en blanc del final. SUBSTR(c1,m[,n]) Torna una subcadena de c1 que comen\u00e7a en el car\u00e0cter m i consta de n car\u00e0cters (per defecte fins el final) LPAD(c1,n[c2]) Torna c1 reomplida per l\u2019esquerra fins n car\u00e0cters amb la cadena c2 TRANSLATE(c1,c2,c3) Torna c1 amb cada car\u00e0cter de c2 substitu\u00eft pel corresponent (en ordre) de c3. LTRIM(c1[,set]) Retalla per l\u2019esquerra mentre troba la cadena set (per defecte blancs) LOWER(c1) Torna la cadena en min\u00fascules UPPER(c1) Torna la cadena en maj\u00fascules Per exemple, traurem els graus de la latitud de les poblacions. Haurem d'agafar els 2 primers car\u00e0cters (els de l'esquerra). SELECT nom , latitud , SUBSTR(latitud,1,2) FROM POBLACIONS; A\u00e7\u00f2 ho podr\u00edem millorar, ja que d'aquesta manera obliguem a que siguen sempre dos car\u00e0cters, els graus. De forma m\u00e9s gen\u00e8rica, els graus \u00e9s el que va davant del s\u00edmbol \u00ba . Per tant el que podem fer \u00e9s buscar aquest s\u00edmbol i traure els de davant (des del primer fins a l'anterior a ell) SELECT nom , latitud , SUBSTR(latitud,1,STRPOS(latitud,'\u00ba')-1) FROM POBLACIONS; Per agafar els minuts de forma senzilla seria traure els car\u00e0cters 4t i 5\u00e8, \u00e9s a dir, 2 car\u00e0cters a partir del 4. SELECT nom , latitud , SUBSTR(latitud,4,2) FROM POBLACIONS; Per\u00f2 de forma m\u00e9s gen\u00e8rica (per si no s'han posat 0 no significatius), haurem de traure des de despr\u00e9s del s\u00edmbol \u00ba fins al car\u00e0ctar anterior a ' (la cometa) que assenyala els minuts. Tenim a m\u00e9s la dificultat afegida que la cometa justament \u00e9s la manera d'especificar un text en SQL. Haurem de posar dos cometes per a escapar, i com que \u00e9s un text va entre cometes. Resultat: 4 cometes. SELECT nom , latitud , SUBSTR(latitud,STRPOS(latitud,'\u00ba')+1,STRPOS(latitud,'''')-STRPOS(latitud,'\u00ba')-1) FROM POBLACIONS; I el mateix far\u00edem per als segons, (entre la cometa simple i la doble). Aquesta sent\u00e8ncia resumeix l'anterior, separant graus, minuts i segons. SELECT nom, latitud, SUBSTR(latitud,1,STRPOS(latitud,'\u00ba')-1), SUBSTR(latitud,STRPOS(latitud,'\u00ba')+1,STRPOS(latitud,'''')-STRPOS(latitud,'\u00ba')-1), SUBSTR(latitud,STRPOS(latitud,'''')+1,STRPOS(latitud,'\"')-STRPOS(latitud,'''')-1) FROM POBLACIONS; Funcions de data Funci\u00f3 Explicaci\u00f3 NOW() (CURRENT_TIMESTAMP) Torna la data-hora actual, amb la difer\u00e8ncia d'hores respecte la GMT LOCALTIMESTAMP Igual que l'anterior, per\u00f2 sense la difer\u00e8ncia de la GMT CURRENT_DATE Torna la data actual CURRENT_TIME Torna l'hora actual (amb difer\u00e8ncia GMT) LOCALTIME Torna l'hora actual (sense difer\u00e8ncia GMT) AGE(t) Torna la difer\u00e8ncia de la data actual i t AGE(t1,t2) Torna la difer\u00e8ncia entre t1 (posterior) i t2 (anterior) EXTRACT(camp FROM t) Trau el n\u00famero corresponent al camp (que pot ser year, month, day, hour, minute, second, millisecond, microsecond, dow (day of week), ... Per exemple, \u00bfquan de temps ha passat des de l'intent de cop d'estat? SELECT AGE('1981/02/23'::DATE); O un altre, \u00bfen quin any estem? SELECT EXTRACT(year FROM CURRENT_DATE); Funcions geom\u00e8triques Funci\u00f3 Explicaci\u00f3 Funci\u00f3 Explicaci\u00f3 AREA(o) \u00c0rea de l'objecte HEIGTH(r) Altura del rect\u00e0ngle CENTER(o) Centre de l'objecte RADIUS(c) Radi del cercle DIAMETER(c) Di\u00e0metre del cercle WIDTH(r) Ampl\u00e0ria del rect\u00e0ngle Per exemple, l'\u00e0rea d'un cercle: SELECT AREA('((5,5),2)'::CIRCLE); Funcions Funci\u00f3 Explicaci\u00f3 Exemple Resultat HOST(ip) Trau en format text l'adre\u00e7a IP HOST('192.168.2.15/24') 192.168.2.15 MASKLEN(ip) Trau el n\u00famero de bits de la m\u00e0scara MASKLEN('192.168.2.15/24') 24 SET_MASKLEN(ip,n) Posa el n\u00famero de bits de la m\u00e0scara als especificats SET_MASKLEN('192.168.2.15/24',16) 192.168.2.15/16 NETMASK(ip) Construeix la m\u00e0scara de xarxa NETMASK('192.168.2.15/24') 255.255.255.0 Funcions de conversi\u00f3 Serviran per a passar d'un tipus a un altre, on un d'ells ser\u00e0 el tipus de cadena (VARCHAR) Funci\u00f3 Explicaci\u00f3 TO_CHAR( data, format ) Converteix una data en una tira de car\u00e0cters, utilitzant el format especificat (es veur\u00e0 aquest format en la seg\u00fcent pregunta) TO_CHAR( n\u00famero, format ) Converteix un n\u00famero en una tira de car\u00e0cters TO_NUMBER( exp., format ) Converteix una tira de car\u00e0cters en un n\u00famero, suposant que estava en el format indicat TO_DATE( exp., format ) Converteix una tira de car\u00e0cters en un data TO_DATETIME( exp., format ) converteix una tira de car\u00e0cters en un data-hora","title":"4.2 Funcions"},{"location":"BD_PostgreSQL_DQL/7_funcions/#421-formats-de-les-dates","text":"Aquest tipus \u00e9s molt vers\u00e0til en quant al format, b\u00e9 siga per a la introducci\u00f3 de les dades, o el que \u00e9s m\u00e9s habitual, per a la seua presentaci\u00f3. S'haur\u00e0 d'utilitzar una funci\u00f3, TO_CHAR , que acceptar\u00e0 2 par\u00e0metres: el primer la data que es vol presentar, i el segon el format que volem. En el format indicarem per mig de determinats car\u00e0cters l'aspecte que volem. Per exemple, per a traure la data d'avui amb el format dia-mes-any, posar\u00edem: SELECT TO_CHAR( NOW(), 'DD-MM-YYYY'); El seg\u00fcent quadre resumeix aquestos car\u00e0cters, agrupat per categories: En principi els formats que tornen lletres ho estaran en angl\u00e8s, per\u00f2 despr\u00e9s veurem com canviar d'idioma. Exemples: Si ara f\u00f3ra 9/1/16 13:39 (en el servidor, no en la vostra m\u00e0quina), i f\u00e9rem SELECT TO_CHAR(NOW(),' format '); Format Eixida dd-mm-yy hh:mi 09-01-23 01:39 dd-mm-yy hh24:mi 09-01-16 13:39 dd-MON-yyy 09-JAN-023 dd-TMMON-yyy 09-ENE-023 (si el tingu\u00e9rem configurat en espanyol) Day, dd \"de\" month \"de\" yyyy Monday , 09 de january de 2023 de 2016 FMDay, dd \"de\" FMmonth \"de\" yyyy. Monday, 09 de january de 2023. TMDay, dd \"de\" TMmonth \"de\" yyyy. Lunes, 09 de enero de 2023. (si el tingu\u00e9rem configurat en espanyol) FMDy PM FMhh-FMmi-FMss Mon PM 1-39-00 TMDy PM TMhh-TMmi-TMss Lun PM 01-39-00 __ (si el tingu\u00e9rem configurat en espanyol)","title":"4.2.1 Formats de les dates"},{"location":"BD_PostgreSQL_DQL/7_funcions/#422-formats-dels-numeros","text":"Tamb\u00e9 podrem utilitzar la funci\u00f3 TO_CHAR per a donar l'aspecte que vulguem als n\u00fameros. En la seg\u00fcent taula tenim un resum amb els diferents s\u00edmbols, un comentari descriptiu de cada s\u00edmbol, i un exemple de format amb el resultat que donaria per a un determinat valor. La sent\u00e8ncia seria SELECT TO_CHAR( valor ,' format '); : Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"4.2.2 Formats dels n\u00fameros"},{"location":"BD_PostgreSQL_DQL/7_la_clusula_having/","text":"7. La cl\u00e0usula HAVING Aquesta cl\u00e0usula acompanya normalment a la de GROUP BY , i servir\u00e0 pera poder triar alguns grups que acomplesquen una determinada condici\u00f3. Pot anar sense el GROUP BY, per\u00f2 aleshores el seu funcionament \u00e9s com el WHERE, i per tant no val la pena. \u00c9s a dir, en la pr\u00e0ctica sempre que trobem un HAVING hi haur\u00e0 tamb\u00e9 el GROUP BY i servir\u00e0 per seleccionar alguns grups, els que acomplesquen la condici\u00f3 del HAVING. Tamb\u00e9 podr\u00edem dir que el HAVING \u00e9s al GROUP BY, el que el WHERE \u00e9s al SELECT Sintaxi SELECT <columnes> FROM <taules> [GROUP BY <columnes>] HAVING <condici\u00f3> \u00danicament comentarem el cas en qu\u00e8 acompanya al GROUP BY. I com hem dit, el que fa \u00e9s filtrar els grups: dels grups resultants del GROUP BY, nom\u00e9s eixiran els que acomplesquen la condici\u00f3. Aquesta condici\u00f3 contindr\u00e0 alguna funci\u00f3 d'agregat o contindr\u00e0 columnes incloses en el GROUP BY. Fixeu-vos que \u00e9s l\u00f2gic, ja que serveix per a triar grups una vegada fets, i aleshores ja no es podr\u00e0 anar a un element del grup. Per exemple, aquesta sent\u00e8ncia servir\u00e0 per traure les comarques on hi ha m\u00e9s de 20 pobles, i el n\u00famero que hi ha: SELECT nom_c, COUNT(*) FROM POBLACIONS GROUP BY nom_c HAVING COUNT(*) > 20; Exemples 1) Traure aquelles poblacions que tenen m\u00e9s d'un de Centres Integrats de Formaci\u00f3 Professional. La manera de saber que \u00e9s un Centre Integrat \u00e9s perqu\u00e8 el seu nom comen\u00e7a per CIPFP. De moment nom\u00e9s traurem el codi de la poblaci\u00f3, i aix\u00ed nom\u00e9s ens fa falta la taula INSTITUTS. M\u00e9s avant aprendrem a agafar les dades de m\u00e9s d'una taula, i aleshores traurem tamb\u00e9 el nom de la poblaci\u00f3 SELECT cod_m, COUNT(*) FROM INSTITUTS WHERE nom LIKE 'CIPFP%' GROUP BY cod_m HAVING COUNT(*) > 1 El que fem en aquesta sent\u00e8ncia \u00e9s, de la taula INSTITUTS seleccionar \u00fanicament els Centres Integrats (utilitzant l'operador LIKE per a que comencen per CIPFP)i i despr\u00e9s agrupar pel codi de municipi. Una vegada fets els grups, eliminarem els grups que no acompleixen la condici\u00f3 de HAVING, \u00e9s a dir, els que tenen 0 o 1 Centre Integrat. I d'aquestos grups seleccionats traurem el codi del municipi i el n\u00famero de Centres Integrats (que sempre ser\u00e0 igual o major que 2). 2) Calcular el n\u00famero d'habitants m\u00e0xim, el m\u00ednim i el n\u00famero d'habitants mitj\u00e0 de les poblacions de les comarques amb m\u00e9s de 20 pobles. SELECT nom_c , COUNT(cod_m) AS \"N\u00famero de pobles\" , Max(poblacio) AS M\u00e0xim , Min(poblacio) AS M\u00ednim , Avg(poblacio) AS Mitjana FROM POBLACIONS GROUP BY nom_c 20; 3) Traure l'altura mitjana, total de poblaci\u00f3 i poblaci\u00f3 mitjana, d'aquelles comarques que tenen una altura mitjana superior a 800 metres. SELECT nom_c , AVG(altura) AS \"Altura mitjana\" , SUM(poblacio) AS \"Total poblaci\u00f3\" , Avg(poblacio) AS \"Poblaci\u00f3 mitjana\" FROM POBLACIONS GROUP BY nom_c HAVING AVG(altura) > 800; Exercicis Ex_28 Calcular la mitjana de quantitats demanades d'aquells articles que s'han demanat m\u00e9s de dues vegades. Observeu que la taula que ens fa falta \u00e9s LINIA_FAC, i que la condici\u00f3 (en el HAVING) \u00e9s sobre el n\u00famero de vegades que entra l'article en una linia de factura, per\u00f2 el resultat que s'ha de mostrar \u00e9s la mitjana de la quantitat. Ex_29 Traure els pobles que tenen entre 3 i 7 clients. Traure nom\u00e9s el codi del poble i aquest n\u00famero Ex_30 Traure les categories que tenen m\u00e9s d'un article \"car\" (de m\u00e9s de 100 \u20ac). Observeu que tamb\u00e9 ens eixir\u00e0 la categoria NULL, \u00e9s a dir, apareixer\u00e0 com una categoria aquells articles que no estan catalogats. Ex_31 Traure els clients que tenen m\u00e9s d'una factura, amb el n\u00famero de factures. Ex_32 Modificar l'anterior per a traure els clients que tenen m\u00e9s d'una factura en el primer trimestre. Ex_33 Calcular el total de cada factura d'aquelles factures que tenen 10 o m\u00e9s l\u00ednies de factura, sense aplicar descomptes ni IVA (com la consulta Ex_26 ), i tamb\u00e9 aplicant el descompte que consta en la l\u00ednia de factura (no el descompte de tota la factura). Tindrem el problema que el valor NULL \u00e9s especial, i en operar amb qualsevol altre valor donar\u00e0 NULL. En aquest cas clarament l'hem de considerar com un descompte 0. Podeu utilitzar una funci\u00f3 que substitueix els HAVING COUNT(cod_m) > valors nuls trobats en el primer par\u00e0metre, pel segon par\u00e0metre d'aquesta manera: COALESCE(dte,0) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"7. La cl\u00e0usula HAVING"},{"location":"BD_PostgreSQL_DQL/7_la_clusula_having/#7-la-clausula-having","text":"Aquesta cl\u00e0usula acompanya normalment a la de GROUP BY , i servir\u00e0 pera poder triar alguns grups que acomplesquen una determinada condici\u00f3. Pot anar sense el GROUP BY, per\u00f2 aleshores el seu funcionament \u00e9s com el WHERE, i per tant no val la pena. \u00c9s a dir, en la pr\u00e0ctica sempre que trobem un HAVING hi haur\u00e0 tamb\u00e9 el GROUP BY i servir\u00e0 per seleccionar alguns grups, els que acomplesquen la condici\u00f3 del HAVING. Tamb\u00e9 podr\u00edem dir que el HAVING \u00e9s al GROUP BY, el que el WHERE \u00e9s al SELECT Sintaxi SELECT <columnes> FROM <taules> [GROUP BY <columnes>] HAVING <condici\u00f3> \u00danicament comentarem el cas en qu\u00e8 acompanya al GROUP BY. I com hem dit, el que fa \u00e9s filtrar els grups: dels grups resultants del GROUP BY, nom\u00e9s eixiran els que acomplesquen la condici\u00f3. Aquesta condici\u00f3 contindr\u00e0 alguna funci\u00f3 d'agregat o contindr\u00e0 columnes incloses en el GROUP BY. Fixeu-vos que \u00e9s l\u00f2gic, ja que serveix per a triar grups una vegada fets, i aleshores ja no es podr\u00e0 anar a un element del grup. Per exemple, aquesta sent\u00e8ncia servir\u00e0 per traure les comarques on hi ha m\u00e9s de 20 pobles, i el n\u00famero que hi ha: SELECT nom_c, COUNT(*) FROM POBLACIONS GROUP BY nom_c HAVING COUNT(*) > 20; Exemples 1) Traure aquelles poblacions que tenen m\u00e9s d'un de Centres Integrats de Formaci\u00f3 Professional. La manera de saber que \u00e9s un Centre Integrat \u00e9s perqu\u00e8 el seu nom comen\u00e7a per CIPFP. De moment nom\u00e9s traurem el codi de la poblaci\u00f3, i aix\u00ed nom\u00e9s ens fa falta la taula INSTITUTS. M\u00e9s avant aprendrem a agafar les dades de m\u00e9s d'una taula, i aleshores traurem tamb\u00e9 el nom de la poblaci\u00f3 SELECT cod_m, COUNT(*) FROM INSTITUTS WHERE nom LIKE 'CIPFP%' GROUP BY cod_m HAVING COUNT(*) > 1 El que fem en aquesta sent\u00e8ncia \u00e9s, de la taula INSTITUTS seleccionar \u00fanicament els Centres Integrats (utilitzant l'operador LIKE per a que comencen per CIPFP)i i despr\u00e9s agrupar pel codi de municipi. Una vegada fets els grups, eliminarem els grups que no acompleixen la condici\u00f3 de HAVING, \u00e9s a dir, els que tenen 0 o 1 Centre Integrat. I d'aquestos grups seleccionats traurem el codi del municipi i el n\u00famero de Centres Integrats (que sempre ser\u00e0 igual o major que 2). 2) Calcular el n\u00famero d'habitants m\u00e0xim, el m\u00ednim i el n\u00famero d'habitants mitj\u00e0 de les poblacions de les comarques amb m\u00e9s de 20 pobles. SELECT nom_c , COUNT(cod_m) AS \"N\u00famero de pobles\" , Max(poblacio) AS M\u00e0xim , Min(poblacio) AS M\u00ednim , Avg(poblacio) AS Mitjana FROM POBLACIONS GROUP BY nom_c 20; 3) Traure l'altura mitjana, total de poblaci\u00f3 i poblaci\u00f3 mitjana, d'aquelles comarques que tenen una altura mitjana superior a 800 metres. SELECT nom_c , AVG(altura) AS \"Altura mitjana\" , SUM(poblacio) AS \"Total poblaci\u00f3\" , Avg(poblacio) AS \"Poblaci\u00f3 mitjana\" FROM POBLACIONS GROUP BY nom_c HAVING AVG(altura) > 800;","title":"7. La cl\u00e0usula HAVING"},{"location":"BD_PostgreSQL_DQL/7_la_clusula_having/#exercicis","text":"Ex_28 Calcular la mitjana de quantitats demanades d'aquells articles que s'han demanat m\u00e9s de dues vegades. Observeu que la taula que ens fa falta \u00e9s LINIA_FAC, i que la condici\u00f3 (en el HAVING) \u00e9s sobre el n\u00famero de vegades que entra l'article en una linia de factura, per\u00f2 el resultat que s'ha de mostrar \u00e9s la mitjana de la quantitat. Ex_29 Traure els pobles que tenen entre 3 i 7 clients. Traure nom\u00e9s el codi del poble i aquest n\u00famero Ex_30 Traure les categories que tenen m\u00e9s d'un article \"car\" (de m\u00e9s de 100 \u20ac). Observeu que tamb\u00e9 ens eixir\u00e0 la categoria NULL, \u00e9s a dir, apareixer\u00e0 com una categoria aquells articles que no estan catalogats. Ex_31 Traure els clients que tenen m\u00e9s d'una factura, amb el n\u00famero de factures. Ex_32 Modificar l'anterior per a traure els clients que tenen m\u00e9s d'una factura en el primer trimestre. Ex_33 Calcular el total de cada factura d'aquelles factures que tenen 10 o m\u00e9s l\u00ednies de factura, sense aplicar descomptes ni IVA (com la consulta Ex_26 ), i tamb\u00e9 aplicant el descompte que consta en la l\u00ednia de factura (no el descompte de tota la factura). Tindrem el problema que el valor NULL \u00e9s especial, i en operar amb qualsevol altre valor donar\u00e0 NULL. En aquest cas clarament l'hem de considerar com un descompte 0. Podeu utilitzar una funci\u00f3 que substitueix els HAVING COUNT(cod_m) > valors nuls trobats en el primer par\u00e0metre, pel segon par\u00e0metre d'aquesta manera: COALESCE(dte,0) Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/8_la_clusula_order_by/","text":"8. La cl\u00e0usula ORDER BY Ordena les files del resultat respecte l'ordre especificat Sintaxi SELECT <columnes> FROM <taules> ORDER BY camp1 [ASC | DESC] { , camp2 [ASC | DESC] } Ac\u00ed tenim un exemple: SELECT nom_c, provincia FROM COMARQUES ORDER BY nom_c S'ordenaran les files pel camp, en l'ordre marcat: ascendent o descendent (per defecte, ascendent). Si hi haguera un segon camp d'ordenaci\u00f3, aquest entraria en joc en cas de valors iguals del primer. Aquest segon podr\u00e0 ser en ordre ascendent o descendent, independentment de l'ordre del primer camp. SELECT nom_c, provincia FROM COMARQUES ORDER BY provincia DESC, nom_c Es podr\u00e0 ordenar per qualsevol camp de la taula, estiga indexada per aquest camp o no. L'avantatge d'estar indexada respecte a un camp \u00e9s la rapidesa en l'ordenaci\u00f3. Aix\u00ed, si tenim una taula gran i ordenem per un determinat camp, es perdr\u00e0 temps en aquesta ordenaci\u00f3. Si cont\u00ednuament estem ordenant per aquest camp, perdrem aquest temps moltes vegades. Aleshores seria convenient crear un \u00edndex. Per\u00f2 hem de recordar que la creaci\u00f3 d'un \u00edndex ocupa espai. Per tant no \u00e9s bona soluci\u00f3 indexar per tots els camps. \u00danicament, en tot cas, per aquells que m\u00e9s s'ordene. Veurem la creaci\u00f3 d'\u00edndex en la tercera part d'aquest tema. I es pot especificar en l'ordenaci\u00f3, una expressi\u00f3 que agafe un o m\u00e9s d'un camp amb operadors i funcions. Es pot posar un camp o una expressi\u00f3 que no estiga en la llista de camps o expressions que es volen visualitzar (al costat del SELECT), encara que normalment s\u00ed que ho visualitzarem, per a poder comprovar que realment est\u00e0 ordenat pel que s'ha especificat. Per exemple, si volem ordenar per la densitat d'habitants de les poblacions, que es calcula dividint el n\u00famero d'habitants per l'extensi\u00f3: SELECT nom, poblacio, extensio FROM POBLACIONS ORDER BY poblacio/extensio DESC Observeu que estem ordenant per un camp ( poblacio / extensio ) que no estem visualitzant, encara que seria molt m\u00e9s il\u00b7lustratiu mostrar-lo Opcionalment, en el moment d'especificar el camp o l'expressi\u00f3 per la qual volem ordenar, si aquesta apareix en la llista de columnes a visualitzar, podrem posar senzillament el n\u00famero d'ordre de la columna. Aix\u00ed, per exemple, podem fer el seg\u00fcent: SELECT nom, poblacio, extensio, poblacio/extensio FROM POBLACIONS ORDER BY 4 DESC On estem indicant que s'ordene de forma descendent per la quarta columna que va a visualitzar-se, \u00e9s a dir, per oblacio / extensio Hem d'observar que la cl\u00e0usula ORDER BY \u00e9s l'\u00faltima, i que en cas d'haver cl\u00e0usula GROUP BY, s'intentar\u00e0 ordenar despr\u00e9s d'haver agrupat. Per tant en cas de que la sent\u00e8ncia continga un GROUP BY o s'haja utilitzat alguna funci\u00f3 d'agregat (que implica fer grups), nom\u00e9s podrem posar en el ORDER BY camps que estiguen en el GROUP BY o que formen part d'una funci\u00f3 d'agregat. El raonament \u00e9s el mateix que el fet en la cl\u00e0usula GROUP BY o HAVING i l'error en cas de no respectar a\u00e7\u00f2 seria el matiex que el vist en aquell apartat. Exemples 1) Traure tota la informaci\u00f3 de les poblacions ordenades pel nom de la poblaci\u00f3. SELECT * FROM POBLACIONS ORDER BY nom 2) Traure tota la informaci\u00f3 de les poblacions, ordenades pel nom de la comarca, i dins d'aquesta per l'altura (de forma descendent). SELECT * FROM POBLACIONS ORDER BY nom_c, altura DESC 3) Traure les comarques amb el n\u00famero de pobles i total d'habitants, d'aquelles que tenen m\u00e9s de 10 pobles, ordenades pel n\u00famero de pobles, i dins d'aquest pel total de poblaci\u00f3 de forma descendent. SELECT nom_c, COUNT(*), SUM(poblacio) FROM POBLACIONS GROUP BY nom_c HAVING COUNT(*) > 10 ORDER BY COUNT(*) , SUM(poblacio) DESC SELECT nom_c, COUNT(*), SUM(poblacio) FROM POBLACIONS GROUP BY nom_c HAVING COUNT(*) > 10 ORDER BY 2 , 3 DESC Exercicis Ex_34 Traure tots els clients ordenats per codi de poblaci\u00f3, i dins d'aquestos per codi postal. Ex_35 Traure tots els articles ordenats per la categoria, dins d'aquest pel stock, i dins d'aquest per preu (de forma descendent) Ex_36 Traure els resultats de la consulta Ex_33 ordenats pel total de la factura quan ja s'ha aplicat el descompte, de forma descendent. Ex_37 Traure tots els articles ordenats per la difer\u00e8ncia entre el stock i el stock m\u00ednim de forma descendent. Com que en moltes ocasions el stock o el stock m\u00ednim \u00e9s nul, hem de considerar en aquestos casos com 0. Per tant hem de tornar a utilitzar la funci\u00f3 COALESCE(stock,0) (i tamb\u00e9 per al stock m\u00ednim). Ex_38 Traure els codis de venedor amb el n\u00famero de factures venudes en el segon semestre de 2015, ordenades per aquest n\u00famero de forma descendent Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"8. La cl\u00e0usula ORDER BY"},{"location":"BD_PostgreSQL_DQL/8_la_clusula_order_by/#8-la-clausula-order-by","text":"Ordena les files del resultat respecte l'ordre especificat Sintaxi SELECT <columnes> FROM <taules> ORDER BY camp1 [ASC | DESC] { , camp2 [ASC | DESC] } Ac\u00ed tenim un exemple: SELECT nom_c, provincia FROM COMARQUES ORDER BY nom_c S'ordenaran les files pel camp, en l'ordre marcat: ascendent o descendent (per defecte, ascendent). Si hi haguera un segon camp d'ordenaci\u00f3, aquest entraria en joc en cas de valors iguals del primer. Aquest segon podr\u00e0 ser en ordre ascendent o descendent, independentment de l'ordre del primer camp. SELECT nom_c, provincia FROM COMARQUES ORDER BY provincia DESC, nom_c Es podr\u00e0 ordenar per qualsevol camp de la taula, estiga indexada per aquest camp o no. L'avantatge d'estar indexada respecte a un camp \u00e9s la rapidesa en l'ordenaci\u00f3. Aix\u00ed, si tenim una taula gran i ordenem per un determinat camp, es perdr\u00e0 temps en aquesta ordenaci\u00f3. Si cont\u00ednuament estem ordenant per aquest camp, perdrem aquest temps moltes vegades. Aleshores seria convenient crear un \u00edndex. Per\u00f2 hem de recordar que la creaci\u00f3 d'un \u00edndex ocupa espai. Per tant no \u00e9s bona soluci\u00f3 indexar per tots els camps. \u00danicament, en tot cas, per aquells que m\u00e9s s'ordene. Veurem la creaci\u00f3 d'\u00edndex en la tercera part d'aquest tema. I es pot especificar en l'ordenaci\u00f3, una expressi\u00f3 que agafe un o m\u00e9s d'un camp amb operadors i funcions. Es pot posar un camp o una expressi\u00f3 que no estiga en la llista de camps o expressions que es volen visualitzar (al costat del SELECT), encara que normalment s\u00ed que ho visualitzarem, per a poder comprovar que realment est\u00e0 ordenat pel que s'ha especificat. Per exemple, si volem ordenar per la densitat d'habitants de les poblacions, que es calcula dividint el n\u00famero d'habitants per l'extensi\u00f3: SELECT nom, poblacio, extensio FROM POBLACIONS ORDER BY poblacio/extensio DESC Observeu que estem ordenant per un camp ( poblacio / extensio ) que no estem visualitzant, encara que seria molt m\u00e9s il\u00b7lustratiu mostrar-lo Opcionalment, en el moment d'especificar el camp o l'expressi\u00f3 per la qual volem ordenar, si aquesta apareix en la llista de columnes a visualitzar, podrem posar senzillament el n\u00famero d'ordre de la columna. Aix\u00ed, per exemple, podem fer el seg\u00fcent: SELECT nom, poblacio, extensio, poblacio/extensio FROM POBLACIONS ORDER BY 4 DESC On estem indicant que s'ordene de forma descendent per la quarta columna que va a visualitzar-se, \u00e9s a dir, per oblacio / extensio Hem d'observar que la cl\u00e0usula ORDER BY \u00e9s l'\u00faltima, i que en cas d'haver cl\u00e0usula GROUP BY, s'intentar\u00e0 ordenar despr\u00e9s d'haver agrupat. Per tant en cas de que la sent\u00e8ncia continga un GROUP BY o s'haja utilitzat alguna funci\u00f3 d'agregat (que implica fer grups), nom\u00e9s podrem posar en el ORDER BY camps que estiguen en el GROUP BY o que formen part d'una funci\u00f3 d'agregat. El raonament \u00e9s el mateix que el fet en la cl\u00e0usula GROUP BY o HAVING i l'error en cas de no respectar a\u00e7\u00f2 seria el matiex que el vist en aquell apartat. Exemples 1) Traure tota la informaci\u00f3 de les poblacions ordenades pel nom de la poblaci\u00f3. SELECT * FROM POBLACIONS ORDER BY nom 2) Traure tota la informaci\u00f3 de les poblacions, ordenades pel nom de la comarca, i dins d'aquesta per l'altura (de forma descendent). SELECT * FROM POBLACIONS ORDER BY nom_c, altura DESC 3) Traure les comarques amb el n\u00famero de pobles i total d'habitants, d'aquelles que tenen m\u00e9s de 10 pobles, ordenades pel n\u00famero de pobles, i dins d'aquest pel total de poblaci\u00f3 de forma descendent. SELECT nom_c, COUNT(*), SUM(poblacio) FROM POBLACIONS GROUP BY nom_c HAVING COUNT(*) > 10 ORDER BY COUNT(*) , SUM(poblacio) DESC SELECT nom_c, COUNT(*), SUM(poblacio) FROM POBLACIONS GROUP BY nom_c HAVING COUNT(*) > 10 ORDER BY 2 , 3 DESC","title":"8. La cl\u00e0usula ORDER BY"},{"location":"BD_PostgreSQL_DQL/8_la_clusula_order_by/#exercicis","text":"Ex_34 Traure tots els clients ordenats per codi de poblaci\u00f3, i dins d'aquestos per codi postal. Ex_35 Traure tots els articles ordenats per la categoria, dins d'aquest pel stock, i dins d'aquest per preu (de forma descendent) Ex_36 Traure els resultats de la consulta Ex_33 ordenats pel total de la factura quan ja s'ha aplicat el descompte, de forma descendent. Ex_37 Traure tots els articles ordenats per la difer\u00e8ncia entre el stock i el stock m\u00ednim de forma descendent. Com que en moltes ocasions el stock o el stock m\u00ednim \u00e9s nul, hem de considerar en aquestos casos com 0. Per tant hem de tornar a utilitzar la funci\u00f3 COALESCE(stock,0) (i tamb\u00e9 per al stock m\u00ednim). Ex_38 Traure els codis de venedor amb el n\u00famero de factures venudes en el segon semestre de 2015, ordenades per aquest n\u00famero de forma descendent Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/9_el_predicat_distinct/","text":"9. El predicat DISTINCT Per defecte, si no especifiquem el contrari, eixiran totes les files de la taula o taules que acomplesquen les condicions. Aix\u00ed, per exemple, si de la taula d'instituts volgu\u00e9rem treure \u00fanicament el codi de la poblaci\u00f3, ens eixiria per exemple 12040 (el codi de Castell\u00f3) en tantes files com instituts de Castell\u00f3 tinguem (concretament 14). \u00c9s el mateix resultat que si hagu\u00e9rem posat el predicat ALL davant de les columnes, ja que aquest \u00e9s el predicat per defecte: SELECT ALL cod_m FROM INSTITUTS Aquest resultat no \u00e9s el correcte, si volem consultes com \"Poblacions on hi ha instituts\". Seria millor si isquera 12040 nom\u00e9s una vegada. A\u00e7\u00f2 ho aconseguirem amb el predicat DISTINCT. En definitiva el que far\u00e0 el predicat DISTINCT ser\u00e0 traure les files diferents del resultat que demanem. Si nom\u00e9s demanem un camp, traur\u00e0 els valors diferents d'aquest camp. Si demanem m\u00e9s d'un camp, traur\u00e0 els valors diferents per al conjunt dels camps (\u00e9s a dir les files diferents, que en un camp poden coincidir, per\u00f2 no en el conjunt de tots els camps) Sintaxi SELECT DISTINCT <columnes > FROM <taules> Aix\u00ed, en l'exemple anterior: SELECT DISTINCT cod_m FROM INSTITUTS Hi ha una variant del DISTINCT que suporta PostgreSQL, per\u00f2 que no suporten altres SGBD m\u00e9s senzills, com Access o LibreOffice Base. \u00c9s posar el DISTINCT dins d'una funci\u00f3 d'agregat, com per exemple COUNT. El resultat \u00e9s que comptar\u00e0 (o la funci\u00f3 implicada: sumar\u00e0 calcular\u00e0 la mitjana, ...) els valors diferents del camp que vaja a continuaci\u00f3. Aix\u00ed per exemple, si volem comptar en quantes poblacions diferents tenim instituts, la consulta \u00e9s tan senzilla com aquesta: SELECT COUNT(DISTINCT cod_m) FROM INSTITUTS Exemples 1) Traure les diferents provincies. SELECT DISTINCT provincia FROM COMARQUES 2) Traure els distints districtes (codis postals) de Castell\u00f3 (codi de municipi 12040) on hi ha instituts SELECT DISTINCT codpostal FROM INSTITUTS WHERE cod_m=12040 3) Traure les distintes comarques i lleng\u00fces que es parlen en elles SELECT DISTINCT nom_c , llengua FROM POBLACIONS ORDER BY 1 Exercicis Ex_39 Traure els venedors que han venut alguna cosa el mes de gener de 2015. Ex_40 Traure els diferents tipus d'IVA que s'han aplicat a les factures de cada venedor, tamb\u00e9 durant el mes de gener de 2015 Ex_41 Traure els diferents caps de venedors (eviteu que aparega el valor nul) Ex_42 Traure els diferents descomptes que s'han aplicat als articles, el codi dels quals comen\u00e7a per SAT . Traure tant el codi d'article com el descompte. 43 Comptar en quantes poblacions tenim clients Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"9. El predicat DISTINCT"},{"location":"BD_PostgreSQL_DQL/9_el_predicat_distinct/#9-el-predicat-distinct","text":"Per defecte, si no especifiquem el contrari, eixiran totes les files de la taula o taules que acomplesquen les condicions. Aix\u00ed, per exemple, si de la taula d'instituts volgu\u00e9rem treure \u00fanicament el codi de la poblaci\u00f3, ens eixiria per exemple 12040 (el codi de Castell\u00f3) en tantes files com instituts de Castell\u00f3 tinguem (concretament 14). \u00c9s el mateix resultat que si hagu\u00e9rem posat el predicat ALL davant de les columnes, ja que aquest \u00e9s el predicat per defecte: SELECT ALL cod_m FROM INSTITUTS Aquest resultat no \u00e9s el correcte, si volem consultes com \"Poblacions on hi ha instituts\". Seria millor si isquera 12040 nom\u00e9s una vegada. A\u00e7\u00f2 ho aconseguirem amb el predicat DISTINCT. En definitiva el que far\u00e0 el predicat DISTINCT ser\u00e0 traure les files diferents del resultat que demanem. Si nom\u00e9s demanem un camp, traur\u00e0 els valors diferents d'aquest camp. Si demanem m\u00e9s d'un camp, traur\u00e0 els valors diferents per al conjunt dels camps (\u00e9s a dir les files diferents, que en un camp poden coincidir, per\u00f2 no en el conjunt de tots els camps) Sintaxi SELECT DISTINCT <columnes > FROM <taules> Aix\u00ed, en l'exemple anterior: SELECT DISTINCT cod_m FROM INSTITUTS Hi ha una variant del DISTINCT que suporta PostgreSQL, per\u00f2 que no suporten altres SGBD m\u00e9s senzills, com Access o LibreOffice Base. \u00c9s posar el DISTINCT dins d'una funci\u00f3 d'agregat, com per exemple COUNT. El resultat \u00e9s que comptar\u00e0 (o la funci\u00f3 implicada: sumar\u00e0 calcular\u00e0 la mitjana, ...) els valors diferents del camp que vaja a continuaci\u00f3. Aix\u00ed per exemple, si volem comptar en quantes poblacions diferents tenim instituts, la consulta \u00e9s tan senzilla com aquesta: SELECT COUNT(DISTINCT cod_m) FROM INSTITUTS Exemples 1) Traure les diferents provincies. SELECT DISTINCT provincia FROM COMARQUES 2) Traure els distints districtes (codis postals) de Castell\u00f3 (codi de municipi 12040) on hi ha instituts SELECT DISTINCT codpostal FROM INSTITUTS WHERE cod_m=12040 3) Traure les distintes comarques i lleng\u00fces que es parlen en elles SELECT DISTINCT nom_c , llengua FROM POBLACIONS ORDER BY 1","title":"9. El predicat DISTINCT"},{"location":"BD_PostgreSQL_DQL/9_el_predicat_distinct/#exercicis","text":"Ex_39 Traure els venedors que han venut alguna cosa el mes de gener de 2015. Ex_40 Traure els diferents tipus d'IVA que s'han aplicat a les factures de cada venedor, tamb\u00e9 durant el mes de gener de 2015 Ex_41 Traure els diferents caps de venedors (eviteu que aparega el valor nul) Ex_42 Traure els diferents descomptes que s'han aplicat als articles, el codi dels quals comen\u00e7a per SAT . Traure tant el codi d'article com el descompte. 43 Comptar en quantes poblacions tenim clients Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL/exercicis_de_tot_el_tema_amb_els_resultats/","text":"Exercicis amb els resultats (part I) En la BD factura , connectant com a usuari factura_alu : Ex_1 Traure tota la informaci\u00f3 dels pobles. Un total de 1663 files Ex_2 Traure el codi postal, el nom i l'adre\u00e7a, per aquest ordre, de tots els venedors.. Ex_3 Traure el codi d'article, la descripci\u00f3, preu i preu incrementat en un 5%, de tots els articles. Un total de 812 files Ex_4 Traure la informaci\u00f3 dels clients amb el seg\u00fcent format (ha d'anar tot en una columna): Damborenea Corbato, Alicia. CALLE MADRID, 83 (12425) Fixeu-vos que est\u00e0 tot en una columna, i per tant haureu de concatenar de la forma adequada. Fixeu-vos tamb\u00e9 que en en el nom nom\u00e9s les inicials estan en maj\u00fascules Un total de 49 files Ex_5 Traure el num_f, data i cod_ven de les factures amb les seg\u00fcents cap\u00e7aleres respectivament: N\u00famero Factura , data i Codi Venedor . Un total de 105 files Ex_6 Donar \u00e0lias als camps que ho necessiten de la taula ARTICLE. Un total de 812 files Ex_7 Traure els clients de la ciutat amb codi 12309 . Ex_8 Traure totes les factures del mes de mar\u00e7 de 2015 . Ex_9 Traure tots els articles de la categoria BjcOlimpia amb un stock entre 2 i 7 unitats. Ex_10 Traure tots els clients que no tenen introdu\u00eft el codi postal . Ex_11 Traure tots els articles amb el stock introdu\u00eft per\u00f2 que no tenen introdu\u00eft el stock m\u00ednim . Ex_12 Traure tots els clients , el primer cognom dels quals \u00e9s VILLALONGA . Ex_13.a Modificar l'anterior per a traure tots els que s\u00f3n VILLALONGA de primer o de segon cognom. Ex_13.b Modificar l'anterior per a traure tots els que no s\u00f3n VILLALONGA ni de primer ni de segon cognom. Un total de 46 files Ex_14 Traure els articles \" Pulsador \" (la descripci\u00f3 cont\u00e9 aquesta paraula), el preu dels quals oscila entre 2 i 4 \u20ac i dels quals tenim un stock estrictament major que el stock m\u00ednim . Ex_15 Comptar el nombre de clients que tenen el codi postal nul . Ex_16 Comptar el n\u00famero de vegades que l'article L76104 entra en les l\u00ednies de factura, i el n\u00famero total d'unitats venudes d'aquest article. Nom\u00e9s us fa falta la taula LINIA_FAC. Ex_17 Traure la mitjana del stock dels articles. Ex_18 Modificar l'anterior per a tenir en compte els valors nuls, com si foren 0 . Us vindr\u00e0 b\u00e9 la funci\u00f3 COALESCE que converteix els nuls del primer par\u00e0metre al valor donat com a segon par\u00e0metre (si \u00e9s diferent de nul, deixa igual el valor). Per tant l'heu d'utilitzar d'aquesta manera: COALESCE(stock,0) Ex_19 Comptar quantes factures t\u00e9 el client 375 Ex_20 Calcular el descompte m\u00e0xim , el m\u00ednim i el descompte mitj\u00e0 de les factures . Ex_21 Comptar el n\u00famero de pobles de cada prov\u00edncia (\u00e9s suficient traure el codi de la prov\u00edncia i el n\u00famero de pobles). Ex_22 Comptar el nombre de clients en cada poble i codi postal. Un total de 45 files Ex_23 Comptar el n\u00famero de factures de cada venedor a cada client. Un total de 96 files D'aquestes 96 files, relativament poque tenen un valor diferent de 1 en el n\u00famero de factures: la fila 29 (455, 30, 2) o la fila 34 (5, 342, 3) Ex_24 Comptar el n\u00famero de factures de cada trimestre. Per a poder traure el trimestre i agrupar per ell (ens val el n\u00famero de trimestre, que va del 1 al 4), podem utilitzar la funci\u00f3 TO_CHAR(data,'Q') . No apareix ordenat, i vol dir que en el trimestre 2 hi ha 25 factures, en el trimestre 4 hi ha 25, en el trimestre 3 hi ha 33 i en el trimestre 1 hi ha 22 Ex_25 Calcular quantes vegades s'ha venut un article, la suma d'unitats venudes, la quantitat m\u00e0xima i la quantitat m\u00ednima. Un total de 399 files Ex_26 Comptar el n\u00famero d'articles de cada categoria i el preu mitj\u00e0. Ex_27 Calcular el total de cada factura, sense aplicar descomptes ni IVA. Nom\u00e9s ens far\u00e0 falta la taula LINIES_FAC , i consistir\u00e0 en agrupar per cada num_f per a calcular la suma del preu multiplicat per la quantitat . Un total de 105 files Ex_28 Calcular la mitjana de quantitats demanades d'aquells articles que s'han demanat m\u00e9s de dues vegades. Observeu que la taula que ens fa falta \u00e9s LINIA_FAC, i que la condici\u00f3 (en el HAVING) \u00e9s sobre el n\u00famero de vegades que entra l'article en una linia de factura, per\u00f2 el resultat que s'ha de mostrar \u00e9s la mitjana de la quantitat. Ex_29 Traure els pobles que tenen entre 3 i 7 clients. Traure nom\u00e9s el codi del poble i aquest n\u00famero Ex_30 Traure les categories que tenen m\u00e9s d'un article \"car\" (de m\u00e9s de 100 \u20ac). Observeu que tamb\u00e9 ens eixir\u00e0 la categoria NULL, \u00e9s a dir, apareixer\u00e0 com una categoria aquells articles que no estan catalogats. Ex_31 Traure els clients que tenen m\u00e9s d'una factura, amb el n\u00famero de factures. Un total de 33 files Ex_32 Modificar l'anterior per a traure els clients que tenen m\u00e9s d'una factura en el primer trimestre. Ex_33 Calcular el total de cada factura d'aquelles factures que tenen 10 o m\u00e9s l\u00ednies de factura, sense aplicar descomptes ni IVA (com la consulta Ex_26 ), i tamb\u00e9 aplicant el descompte que consta en la l\u00ednia de factura (no el descompte de tota la factura). Tindrem el problema que el valor NULL \u00e9s especial, i en operar amb qualsevol altre valor donar\u00e0 NULL. En aquest cas clarament l'hem de considerar com un descompte 0. Podeu utilitzar una funci\u00f3 que substitueix els valors nuls trobats en el primer par\u00e0metre, pel segon par\u00e0metre d'aquesta manera: COALESCE(dte,0) Ex_34 Traure tots els clients ordenats per codi de poblaci\u00f3, i dins d'aquestos per codi postal. Un total de 49 files Ex_35 Traure tots els articles ordenats per la categoria, dins d'aquest pel stock, i dins d'aquest per preu (de forma descendent) Un total de 812 files Ex_36 Traure els resultats de la consulta 6.33 ordenats pel total de la factura quan ja s'ha aplicat el descompte, de forma descendent. Ex_37 Traure tots els articles ordenats per la difer\u00e8ncia entre el stock i el stock m\u00ednim de forma descendent. Com que en moltes ocasions el stock o el stock m\u00ednim \u00e9s nul, hem de considerar en aquestos casos com 0. Per tant hem de tornar a utilitzar la funci\u00f3 COALESCE(stock,0) (i tamb\u00e9 per al stock m\u00ednim). Un total de 812 files Ex_38 Traure els codis de venedor amb el n\u00famero de factures venudes en el segon semestre de 2015, ordenades per aquest n\u00famero de forma descendent Ex_39 Traure els venedors que han venut alguna cosa el mes de gener de 2015. Ex_40 Traure els diferents tipus d'IVA que s'han aplicat a les factures de cada venedor, tamb\u00e9 durant el mes de gener de 2015 Ex_41 Traure els diferents caps de venedors (eviteu que aparega el valor nul) Ex_42 Traure els diferents descomptes que s'han aplicat als articles, el codi dels quals comen\u00e7a per SAT . Traure tant el codi d'article com el descompte. Ex_43 Comptar en quantes poblacions tenim clients Ex_44 Traure tota la informaci\u00f3 dels dos articles m\u00e9s cars. Ex_45 Traure el codi de les tres ciutats amb m\u00e9s clients Ex_46 Traure el venedor que ha venut menys factures Ex_47 Traure les tres factures m\u00e9s cares (sense comptar els descomptes) Ex_48 Modificar l'anterior per a traure totes les factures, excepte les 3 m\u00e9s cares. Un total de 102 files Ex_49 Crear una taula anomenada ARTICLE_999x , on 999 han de ser les 3 \u00faltimes xifres del DNI, i x la lletra del teu NIF, que siga una c\u00f2pia de la taula ARTICLE, per\u00f2 substituint els valors nuls de stock i stock_min per zeros. El resultat ha de ser la creaci\u00f3 de la taula. Si consulteu el seu contingut ha de ser el seg\u00fcent: Untotal de 812 files Ex_50 Utilitzar la taula anterior per a traure el stock m\u00e0xim, el m\u00ednim i la mitjana de stocks. Observeu que si utilitz\u00e0rem la taula ARTICLE, els resultats no serien els mateixos (excepte el m\u00e0xim), sobretot la mitjana, ja que els valors nuls no entrarien en els c\u00e0lculs d'aquesta mitjana. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis amb els resultats (part I)"},{"location":"BD_PostgreSQL_DQL/exercicis_de_tot_el_tema_amb_els_resultats/#exercicis-amb-els-resultats-part-i","text":"En la BD factura , connectant com a usuari factura_alu : Ex_1 Traure tota la informaci\u00f3 dels pobles. Un total de 1663 files Ex_2 Traure el codi postal, el nom i l'adre\u00e7a, per aquest ordre, de tots els venedors.. Ex_3 Traure el codi d'article, la descripci\u00f3, preu i preu incrementat en un 5%, de tots els articles. Un total de 812 files Ex_4 Traure la informaci\u00f3 dels clients amb el seg\u00fcent format (ha d'anar tot en una columna): Damborenea Corbato, Alicia. CALLE MADRID, 83 (12425) Fixeu-vos que est\u00e0 tot en una columna, i per tant haureu de concatenar de la forma adequada. Fixeu-vos tamb\u00e9 que en en el nom nom\u00e9s les inicials estan en maj\u00fascules Un total de 49 files Ex_5 Traure el num_f, data i cod_ven de les factures amb les seg\u00fcents cap\u00e7aleres respectivament: N\u00famero Factura , data i Codi Venedor . Un total de 105 files Ex_6 Donar \u00e0lias als camps que ho necessiten de la taula ARTICLE. Un total de 812 files Ex_7 Traure els clients de la ciutat amb codi 12309 . Ex_8 Traure totes les factures del mes de mar\u00e7 de 2015 . Ex_9 Traure tots els articles de la categoria BjcOlimpia amb un stock entre 2 i 7 unitats. Ex_10 Traure tots els clients que no tenen introdu\u00eft el codi postal . Ex_11 Traure tots els articles amb el stock introdu\u00eft per\u00f2 que no tenen introdu\u00eft el stock m\u00ednim . Ex_12 Traure tots els clients , el primer cognom dels quals \u00e9s VILLALONGA . Ex_13.a Modificar l'anterior per a traure tots els que s\u00f3n VILLALONGA de primer o de segon cognom. Ex_13.b Modificar l'anterior per a traure tots els que no s\u00f3n VILLALONGA ni de primer ni de segon cognom. Un total de 46 files Ex_14 Traure els articles \" Pulsador \" (la descripci\u00f3 cont\u00e9 aquesta paraula), el preu dels quals oscila entre 2 i 4 \u20ac i dels quals tenim un stock estrictament major que el stock m\u00ednim . Ex_15 Comptar el nombre de clients que tenen el codi postal nul . Ex_16 Comptar el n\u00famero de vegades que l'article L76104 entra en les l\u00ednies de factura, i el n\u00famero total d'unitats venudes d'aquest article. Nom\u00e9s us fa falta la taula LINIA_FAC. Ex_17 Traure la mitjana del stock dels articles. Ex_18 Modificar l'anterior per a tenir en compte els valors nuls, com si foren 0 . Us vindr\u00e0 b\u00e9 la funci\u00f3 COALESCE que converteix els nuls del primer par\u00e0metre al valor donat com a segon par\u00e0metre (si \u00e9s diferent de nul, deixa igual el valor). Per tant l'heu d'utilitzar d'aquesta manera: COALESCE(stock,0) Ex_19 Comptar quantes factures t\u00e9 el client 375 Ex_20 Calcular el descompte m\u00e0xim , el m\u00ednim i el descompte mitj\u00e0 de les factures . Ex_21 Comptar el n\u00famero de pobles de cada prov\u00edncia (\u00e9s suficient traure el codi de la prov\u00edncia i el n\u00famero de pobles). Ex_22 Comptar el nombre de clients en cada poble i codi postal. Un total de 45 files Ex_23 Comptar el n\u00famero de factures de cada venedor a cada client. Un total de 96 files D'aquestes 96 files, relativament poque tenen un valor diferent de 1 en el n\u00famero de factures: la fila 29 (455, 30, 2) o la fila 34 (5, 342, 3) Ex_24 Comptar el n\u00famero de factures de cada trimestre. Per a poder traure el trimestre i agrupar per ell (ens val el n\u00famero de trimestre, que va del 1 al 4), podem utilitzar la funci\u00f3 TO_CHAR(data,'Q') . No apareix ordenat, i vol dir que en el trimestre 2 hi ha 25 factures, en el trimestre 4 hi ha 25, en el trimestre 3 hi ha 33 i en el trimestre 1 hi ha 22 Ex_25 Calcular quantes vegades s'ha venut un article, la suma d'unitats venudes, la quantitat m\u00e0xima i la quantitat m\u00ednima. Un total de 399 files Ex_26 Comptar el n\u00famero d'articles de cada categoria i el preu mitj\u00e0. Ex_27 Calcular el total de cada factura, sense aplicar descomptes ni IVA. Nom\u00e9s ens far\u00e0 falta la taula LINIES_FAC , i consistir\u00e0 en agrupar per cada num_f per a calcular la suma del preu multiplicat per la quantitat . Un total de 105 files Ex_28 Calcular la mitjana de quantitats demanades d'aquells articles que s'han demanat m\u00e9s de dues vegades. Observeu que la taula que ens fa falta \u00e9s LINIA_FAC, i que la condici\u00f3 (en el HAVING) \u00e9s sobre el n\u00famero de vegades que entra l'article en una linia de factura, per\u00f2 el resultat que s'ha de mostrar \u00e9s la mitjana de la quantitat. Ex_29 Traure els pobles que tenen entre 3 i 7 clients. Traure nom\u00e9s el codi del poble i aquest n\u00famero Ex_30 Traure les categories que tenen m\u00e9s d'un article \"car\" (de m\u00e9s de 100 \u20ac). Observeu que tamb\u00e9 ens eixir\u00e0 la categoria NULL, \u00e9s a dir, apareixer\u00e0 com una categoria aquells articles que no estan catalogats. Ex_31 Traure els clients que tenen m\u00e9s d'una factura, amb el n\u00famero de factures. Un total de 33 files Ex_32 Modificar l'anterior per a traure els clients que tenen m\u00e9s d'una factura en el primer trimestre. Ex_33 Calcular el total de cada factura d'aquelles factures que tenen 10 o m\u00e9s l\u00ednies de factura, sense aplicar descomptes ni IVA (com la consulta Ex_26 ), i tamb\u00e9 aplicant el descompte que consta en la l\u00ednia de factura (no el descompte de tota la factura). Tindrem el problema que el valor NULL \u00e9s especial, i en operar amb qualsevol altre valor donar\u00e0 NULL. En aquest cas clarament l'hem de considerar com un descompte 0. Podeu utilitzar una funci\u00f3 que substitueix els valors nuls trobats en el primer par\u00e0metre, pel segon par\u00e0metre d'aquesta manera: COALESCE(dte,0) Ex_34 Traure tots els clients ordenats per codi de poblaci\u00f3, i dins d'aquestos per codi postal. Un total de 49 files Ex_35 Traure tots els articles ordenats per la categoria, dins d'aquest pel stock, i dins d'aquest per preu (de forma descendent) Un total de 812 files Ex_36 Traure els resultats de la consulta 6.33 ordenats pel total de la factura quan ja s'ha aplicat el descompte, de forma descendent. Ex_37 Traure tots els articles ordenats per la difer\u00e8ncia entre el stock i el stock m\u00ednim de forma descendent. Com que en moltes ocasions el stock o el stock m\u00ednim \u00e9s nul, hem de considerar en aquestos casos com 0. Per tant hem de tornar a utilitzar la funci\u00f3 COALESCE(stock,0) (i tamb\u00e9 per al stock m\u00ednim). Un total de 812 files Ex_38 Traure els codis de venedor amb el n\u00famero de factures venudes en el segon semestre de 2015, ordenades per aquest n\u00famero de forma descendent Ex_39 Traure els venedors que han venut alguna cosa el mes de gener de 2015. Ex_40 Traure els diferents tipus d'IVA que s'han aplicat a les factures de cada venedor, tamb\u00e9 durant el mes de gener de 2015 Ex_41 Traure els diferents caps de venedors (eviteu que aparega el valor nul) Ex_42 Traure els diferents descomptes que s'han aplicat als articles, el codi dels quals comen\u00e7a per SAT . Traure tant el codi d'article com el descompte. Ex_43 Comptar en quantes poblacions tenim clients Ex_44 Traure tota la informaci\u00f3 dels dos articles m\u00e9s cars. Ex_45 Traure el codi de les tres ciutats amb m\u00e9s clients Ex_46 Traure el venedor que ha venut menys factures Ex_47 Traure les tres factures m\u00e9s cares (sense comptar els descomptes) Ex_48 Modificar l'anterior per a traure totes les factures, excepte les 3 m\u00e9s cares. Un total de 102 files Ex_49 Crear una taula anomenada ARTICLE_999x , on 999 han de ser les 3 \u00faltimes xifres del DNI, i x la lletra del teu NIF, que siga una c\u00f2pia de la taula ARTICLE, per\u00f2 substituint els valors nuls de stock i stock_min per zeros. El resultat ha de ser la creaci\u00f3 de la taula. Si consulteu el seu contingut ha de ser el seg\u00fcent: Untotal de 812 files Ex_50 Utilitzar la taula anterior per a traure el stock m\u00e0xim, el m\u00ednim i la mitjana de stocks. Observeu que si utilitz\u00e0rem la taula ARTICLE, els resultats no serien els mateixos (excepte el m\u00e0xim), sobretot la mitjana, ja que els valors nuls no entrarien en els c\u00e0lculs d'aquesta mitjana. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Exercicis amb els resultats (part I)"},{"location":"BD_PostgreSQL_DQL/objectius_i_coneixements_previs/","text":"Objectius i Coneixements previs Objectius L'objectiu primordial \u00e9s dominar el llenguatge SQL , per a poder fer sent\u00e8ncies de dificultat mitjana-alta. En particular s'hauran de saber fer: Consultes DDL per a crear, modificar i esborrar taules i vistes. Consultes DML per a inserir, modificar o esborrar files d'una taula. Consultes SELECT, per a traure informaci\u00f3 de les taules. Concretament s'haur\u00e0 de con\u00e9ixer a la perfecci\u00f3 totes les seues cl\u00e0usules. Consultes SELECT amb combinacions o reunions de taules, incloent les combinacions externes (LEFT JOIN). Consultes d'uni\u00f3 Subconsultes Un altre objectiu \u00e9s el de con\u00e8ixer l'arquitectura client-servidor , i per a aconseguir a\u00e7\u00f2 treballarem en PostgreSQL . Mentre que en Access cadasc\u00fa tenia la seua pr\u00f2pia Base de Dades, ara en PostgreSQL la Base de Dades est\u00e0 en un \u00fanic lloc remot, en el servidor. I tots ens connectem com a usuaris al servidor (com a clients). Per ser m\u00e9s conscients, ens connectarem com el mateix usuari a la mateixa Base de Dades, compartint per tant les dades, excepte quan ens toque crear objectes, que cadasc\u00fa es connectar\u00e0 com un usuari diferent a una Base de Dades diferent, per a no interferir els uns amb els altres. Per l'extensi\u00f3 del tema, el dividirem en 3 parts. Per motius did\u00e0ctics comen\u00e7arem per la sent\u00e8ncia SELECT, en la seua forma m\u00e9s senzilla. Continuarem amb les consultes m\u00e9s complicades del SELECT. Per \u00faltim veurem les sent\u00e8ncies DDL i les de manipulaci\u00f3 de dades. Coneixements previs Els coneixements previs estrictes del tema \u00e9s el Model Relacional, encara que no el podrem deslligar de tot l'entorn que ens estem construint a l'hora de dissenyar una Base de Dades, i aix\u00ed el tema del Model Entitat-Relaci\u00f3 tamb\u00e9 ens vindr\u00e0 molt b\u00e9. I per a poder practicar ens fa falta un SGBD. S'ha optat per un SGBD nou no vist encara, PostgreSQL , pel comentat en el punt anterior. Com \u00e9s la primera vegada que es veu, no hi ha coneixements previs de cap entorn d'aquest SGBD. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Objectius i Coneixements previs"},{"location":"BD_PostgreSQL_DQL/objectius_i_coneixements_previs/#objectius-i-coneixements-previs","text":"","title":"Objectius i Coneixements previs"},{"location":"BD_PostgreSQL_DQL/objectius_i_coneixements_previs/#objectius","text":"L'objectiu primordial \u00e9s dominar el llenguatge SQL , per a poder fer sent\u00e8ncies de dificultat mitjana-alta. En particular s'hauran de saber fer: Consultes DDL per a crear, modificar i esborrar taules i vistes. Consultes DML per a inserir, modificar o esborrar files d'una taula. Consultes SELECT, per a traure informaci\u00f3 de les taules. Concretament s'haur\u00e0 de con\u00e9ixer a la perfecci\u00f3 totes les seues cl\u00e0usules. Consultes SELECT amb combinacions o reunions de taules, incloent les combinacions externes (LEFT JOIN). Consultes d'uni\u00f3 Subconsultes Un altre objectiu \u00e9s el de con\u00e8ixer l'arquitectura client-servidor , i per a aconseguir a\u00e7\u00f2 treballarem en PostgreSQL . Mentre que en Access cadasc\u00fa tenia la seua pr\u00f2pia Base de Dades, ara en PostgreSQL la Base de Dades est\u00e0 en un \u00fanic lloc remot, en el servidor. I tots ens connectem com a usuaris al servidor (com a clients). Per ser m\u00e9s conscients, ens connectarem com el mateix usuari a la mateixa Base de Dades, compartint per tant les dades, excepte quan ens toque crear objectes, que cadasc\u00fa es connectar\u00e0 com un usuari diferent a una Base de Dades diferent, per a no interferir els uns amb els altres. Per l'extensi\u00f3 del tema, el dividirem en 3 parts. Per motius did\u00e0ctics comen\u00e7arem per la sent\u00e8ncia SELECT, en la seua forma m\u00e9s senzilla. Continuarem amb les consultes m\u00e9s complicades del SELECT. Per \u00faltim veurem les sent\u00e8ncies DDL i les de manipulaci\u00f3 de dades.","title":"Objectius"},{"location":"BD_PostgreSQL_DQL/objectius_i_coneixements_previs/#coneixements-previs","text":"Els coneixements previs estrictes del tema \u00e9s el Model Relacional, encara que no el podrem deslligar de tot l'entorn que ens estem construint a l'hora de dissenyar una Base de Dades, i aix\u00ed el tema del Model Entitat-Relaci\u00f3 tamb\u00e9 ens vindr\u00e0 molt b\u00e9. I per a poder practicar ens fa falta un SGBD. S'ha optat per un SGBD nou no vist encara, PostgreSQL , pel comentat en el punt anterior. Com \u00e9s la primera vegada que es veu, no hi ha coneixements previs de cap entorn d'aquest SGBD. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial CompartirIgual 3.0","title":"Coneixements previs"},{"location":"BD_PostgreSQL_DQL_Avancat/","text":"Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"Index"},{"location":"BD_PostgreSQL_DQL_Avancat/21_introducci/","text":"1 Introducci\u00f3 En la primera part del tema s'ha repassat tota la sintaxi de la sent\u00e8ncia SELECT. Una vegada conegudes totes les cl\u00e0usules, \u00e9s moment de traure tota la pot\u00e8ncia de SQL accedint a Bases de Dades Relacionals, fent unes sent\u00e8ncies \"avan\u00e7ades\", d'un nivell de complexitat major que fins ara. Els tipus de sent\u00e8ncies avan\u00e7ades que veurem seran: Combinacions de taules, en les quals entrar\u00e0 en joc m\u00e9s d'una taula. Veurem les distintes possibilitats que tindrem. Subconsultes, on tindrem una sent\u00e8ncia SQL dins d'una altra. Consultes d'uni\u00f3, on unirem m\u00e9s d'una sent\u00e8ncia SQL. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"1. Introducci\u00f3"},{"location":"BD_PostgreSQL_DQL_Avancat/21_introducci/#1-introduccio","text":"En la primera part del tema s'ha repassat tota la sintaxi de la sent\u00e8ncia SELECT. Una vegada conegudes totes les cl\u00e0usules, \u00e9s moment de traure tota la pot\u00e8ncia de SQL accedint a Bases de Dades Relacionals, fent unes sent\u00e8ncies \"avan\u00e7ades\", d'un nivell de complexitat major que fins ara. Els tipus de sent\u00e8ncies avan\u00e7ades que veurem seran: Combinacions de taules, en les quals entrar\u00e0 en joc m\u00e9s d'una taula. Veurem les distintes possibilitats que tindrem. Subconsultes, on tindrem una sent\u00e8ncia SQL dins d'una altra. Consultes d'uni\u00f3, on unirem m\u00e9s d'una sent\u00e8ncia SQL. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"1 Introducci\u00f3"},{"location":"BD_PostgreSQL_DQL_Avancat/22_combinacions_de_taules/","text":"2 Combinacions de taules Vam veure en la sent\u00e8ncia b\u00e0sica que en la cl\u00e0usula FROM pos\u00e0vem la taula o taules d'on s'agafarien les dades, per\u00f2 en tots els exemples posteriors nom\u00e9s entrava en joc una \u00fanica taula. \u00c9s el moment d'estudiar les diferents possibilitats que tindrem quan posem m\u00e9s d'una taula. La primera \u00e9s el producte cartesi\u00e0 , que no utilitzarem mai, per\u00f2 hem de saber en qu\u00e8 consisteix per poder evitar-lo. La segona ser\u00e0 la m\u00e9s utilitzada, la combinaci\u00f3 (que de vegades anomenarem reuni\u00f3 ). La tercera \u00e9s una variant de l'anterior, la combinaci\u00f3 externa , molt \u00fatil en alguns casos. 2.1 Producte cartesi\u00e0 La manera m\u00e9s senzilla \u00e9s posar les taules separades per comes, per\u00f2 segurament el resultat no \u00e9s el que esper\u00e0vem. Per exemple podem fer la seg\u00fcent sent\u00e8ncia: SELECT COMARQUES.nom_c, nom FROM COMARQUES,POBLACIONS; Nota Observeu que hem posat el nom de la taula davant del camp nom_c , perqu\u00e8 les dues taules tenen un camp amb aquest nom. Aquesta operaci\u00f3 s'anomena qualificaci\u00f3 . Si no qualific\u00e0rem amb el nom de la taula davant, hi hauria ambig\u00fcitat, no sabria a quin camp es refereix, si el d'una taula o el de l'altra. Quan els noms dels camps s\u00f3n diferents i per tant no coincideixen en les dues taules, no cal qualificar el camp (com per exemple amb el camp nom ) Si executem la sent\u00e8ncia, veurem que tindrem un nombre de files inesperadament alt, 18.428 files !!! I si analitzem les files veurem el perqu\u00e8: s'ha combinat cada comarca amb tots els pobles (siguen de la comarca o no). Aquesta operaci\u00f3 s'anomena PRODUCTE CARTESI\u00c0 ( cross join ), i es caracteritza en qu\u00e8 cadascuna de les files d'una taula es combina amb totes les files de l'altra taula. El nombre de files resultant ser\u00e0, doncs, el resultat de multiplicar el nombre de files d'una taula pel nombre de files de l'altra taula (en el nostre cas 34 x 542 = 18428). Rarament voldrem fer un producte cartesi\u00e0. El m\u00e9s normal ser\u00e0 combinar una miqueta millor les taules. En el nostre exemple segurament ens interessar\u00e0 molt m\u00e9s combinar cada comarca amb les seues poblacions . 2.2 Combinaci\u00f3 interna Combinaci\u00f3 de dues taules: Sintaxi Normalment el producte cartesi\u00e0 no ens interessar\u00e0. M\u00e9s b\u00e9 voldrem combinar les taules de manera que dos camps, un camp de cada taula, coincidesquen. I el m\u00e9s habitual, si tenim la Base de Dades ben dissenyada, ser\u00e0 que els camps coincidents siguen una clau externa amb la clau principal a la qual apunta. Aix\u00ed, en l'exemple que utilitz\u00e0vem en el punt anterior, el que s\u00ed que ens ser\u00e0 \u00fatil \u00e9s combinar cada comarca amb les seues poblacions. I justament tenim un camp en la taula POBLACIONS, nom_c , que \u00e9s clau externa i apunta a la clau principal de COMARQUES . Aquesta operaci\u00f3 l'anomenarem COMBINACI\u00d3 INTERNA o senzillament COMBINACI\u00d3 , i de vegades tamb\u00e9 es diu REUNI\u00d3 . La seua sintaxi \u00e9s la seg\u00fcent: SELECT ... FROM taula1 INNER JOIN taula2 ON _condici\u00f3_ La condici\u00f3 de la reuni\u00f3 consistir\u00e0 en comparar un camp de cada taula. Els dos camps hauran de ser del mateix tipus, per\u00f2 no caldr\u00e0 que tinguen el mateix nom. Les files que eixiran al resultat seran les que acompliran la condici\u00f3. Encara que els operadors que es poden utilitzar s\u00f3n tots els de comparaci\u00f3, en la pr\u00e0ctica SEMPRE utilitzarem el d'igualar. Per tant podem refinar millor la combinaci\u00f3 de 2 taules SELECT ... FROM taula1 INNER JOIN taula2 ON taula1.camp1 = taula2.camp2 L'exemple de les comarques i les seues poblacions quedar\u00e0 aix\u00ed SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c = POBLACIONS.nom_c I aquest seria el resultat que com veiem torna 542 files (tantes com pobles) Alternativament, podr\u00edem posar la mateixa reuni\u00f3 d'una altra forma: SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES,POBLACIONS WHERE COMARQUES.nom_c = POBLACIONS.nom_c on estrictament el que estem fent \u00e9s, del producte cartesi\u00e0 de les 2 taules, seleccionar \u00fanicament quan coincideix el nom_c (\u00e9s a dir la comarca amb les seues poblacions), i per tant el resultat seria el mateix. Potser f\u00f3ra m\u00e9s eficient utilitzar la primera manera, per\u00f2 de vegades la comoditat ens far\u00e0 utilitzar la segona (sobretot quan s'hagen de combinar moltes taules). Les dues maneres de posar la conbinaci\u00f3 de dues taules s\u00f3n les m\u00e9s habituals, i que funcionen en qualsevol Sistema Gestor de Bases de Dades. Tanmateix en PostgreSQL (i en altres SGBD com Oracle) hi ha m\u00e9s maneres de fer una combinaci\u00f3. No les veurem tan a fons perqu\u00e8 les anteriors ens basten i sobren: INNER JOIN amb USING : En el cas que els camps a reunir de les dues taules es diguen exactament igual, podem substituir la condici\u00f3 posada en ON per l'expressi\u00f3 USING , amb el camp de la reuni\u00f3 entre par\u00e8ntesis SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) NATURAL JOIN : Tamb\u00e9 per al cas anterior, en qu\u00e8 el camp en les dues taules es diu igual, podem fer-lo de forma encara m\u00e9s abreviada. Far\u00e0 una reuni\u00f3, igualant tots els camps que es diguen igual de les dues taules. Hem d'anar en compte, per si de cas hi ha algun altre camp en les dues taules que es diga igual. SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES NATURAL JOIN POBLACIONS Exemples 1) Traure el noms de les Poblacions i els noms dels Instituts que hi ha en elles. Haurem de combinar les taules per la clau externa d'INSTITUTS a POBLACIONS (\u00e9s a dir la que apunta de cod_m en INSTITUTS fins a la clau principal de COMARQUES, que \u00e9s justament cod_m). SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS INNER JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m; Utilitzant l'altra sintaxi, que posem la condici\u00f3 en el WHERE , ens quedaria: SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS , INSTITUTS WHERE POBLACIONS.cod_m=INSTITUTS.cod_m; Com en aquest cas el camp que hem d'igualar t\u00e9 el mateix nom en les dues taules, utilitzant la sintaxi del USING ens quedari m\u00e9s f\u00e0cil: SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS INNER JOIN INSTITUTS USING(cod_m); En canvi, hem d'anar amb molt de compte amb la sintaxi del NATURAL JOIN , perqu\u00e8 itentar\u00e0 igualar tots els camps que es diuen igual, i en aquest cas tenim dos camps coincidents: cod_m i nom. cod_m \u00e9s el que volem, per\u00f2 nom ens fastidiar\u00e0, i evidentment no coincideix mai el nom de l'Institut i el de la poblaci\u00f3, i per tant no tornar\u00e0 cap fila. SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS NATURAL JOIN INSTITUTS; 2) Traure els noms de les comarques i la prov\u00edncia, amb el nombre de poblacions que t\u00e9 cada comarca. Ens fan falta dues taules, COMARQUES per a poder traure el nom de la comarca i la prov\u00edncia, i POBLACIONS per a poder comptar els pobles de cada comarca. Les haurem de combinar, agrupar per comarca (i prov\u00edncia tamb\u00e9, perqu\u00e8 volem que aparega el nom de la prov\u00edncia) i comptar les poblacions. A l'hora de comptar podem comptar files (COUNT(*)), per\u00f2 potser siga millor comptar algun camp de la taula POBLACIONS, per exemple cod_m, que \u00e9s la clau principal (recordem que els valors nuls no es comptaran, i cod_m per ser clau principal no pot ser nul). SELECT COMARQUES.nom_c, provincia, COUNT(cod_m) AS Quants FROM COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c GROUP BY COMARQUES.nom_c, provincia; Tres o m\u00e9s taules Si tenim m\u00e9s de 2 taules, haurem de procedir de la mateixa manera, ja que si deixem de combinar alguna taula, tindrem el producte cartesi\u00e0. Com en la immensa majoria de casos, la reuni\u00f3 la farem per les claus externes que tenim definides. \u00danicament haurem de cuidar els par\u00e8ntesis, per a marcar primer una condici\u00f3 de combinaci\u00f3 i despr\u00e9s l'altra. En un exemple ho veurem perfectament il\u00b7lustrat. Intentem traure el nom d'una comarca i la prov\u00edncia, el nom dels seus pobles i el nom dels instituts d'aquestos pobles. Ens fan falta les taules COMARQUES (pera poder traure el nom de la comarca i prov\u00edncia), POBLACIONS (per a traure el nom de la poblaci\u00f3) i INSTITUTS (per al nom d'aquestos). Ordenarem per nom de comarca, i dins d'aquest per poblaci\u00f3, per a una millor lectura del resultat SELECT COMARQUES.nom_c, provincia, POBLACIONS.nom, INSTITUTS.nom FROM (COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c) INNER JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m ORDER BY 1,3; Podr\u00edem posar la consulta de la forma alternativa, en qu\u00e8 les condicions de reuni\u00f3 van en el WHERE. \u00d2bviament aquestes condicions han d'anar unides per l'operador AND. SELECT COMARQUES.nom_c, provincia, POBLACIONS.nom, INSTITUTS.nom FROM COMARQUES , POBLACIONS , INSTITUTS WHERE COMARQUES.nom_c=POBLACIONS.nom_c AND POBLACIONS.cod_m=INSTITUTS.cod_m ORDER BY 1,3; Anem a plantejar un altre exemple. Es tracta de traure el nom i la prov\u00edncia de les comarques, amb el n\u00famero d'Instituts que hi ha en elles. En principi podr\u00edem pensar que les \u00faniques taules que ens fan falta s\u00f3n COMARQUES (per a traure el nom i prov\u00edncia de la comarca) i INSTITUTS (per a poder comptar els INSTITUTS). Si intentem fer aquesta consulta, NO obtindrem el resultat desitjat. Aviso SELECT nom_c, provincia, COUNT(codi) FROM COMARQUES , INSTITUTS) GROUP BY nom_c, provincia) Evidentment hi haur\u00e0 un producte cartesi\u00e0, ja que no hem combinat les taules, i ens eixir\u00e0 per a cada comarca 375 instituts, que \u00e9s el n\u00famero total d'instituts, ja que s'ha combinat cada comarca amb tots els instituts. Per\u00f2 aleshores, per quin camp combinem? Si intentem unir les claus principals, nom_c amb codi (el codi d'Institut) no poden combinar b\u00e9 per raons evidents. Ens hem de fixar en el disseny de la Base de Dades. Observarem que el problema \u00e9s que no hi ha una clau externa entre INSTITUTS i COMARQUES. Per\u00f2 tamb\u00e9 ens d\u00f3na la soluci\u00f3: haurem de posar tamb\u00e9 la taula POBLACIONS encara que no vulguem visualitzar cap camp d'aquesta taula, ja que si estan relacionades les taules INSTITUTS i COMARQUES \u00e9s a trav\u00e9s d'aquesta taula. Per tant la consulta correcta ser\u00e0: SELECT COMARQUES.nom_c, provincia, COUNT(codi) FROM (COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c) INNER JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m GROUP BY COMARQUES.nom_c, provincia La forma alternativa sembla m\u00e9s curta. Est\u00e0 clar que si s\u00f3n 3 taules, hauran d'haver 2 condicions de combinaci\u00f3 unides per AND. SELECT COMARQUES.nom_c, provincia, COUNT(codi) FROM COMARQUES , POBLACIONS , INSTITUTS WHERE COMARQUES.nom_c=POBLACIONS.nom_c AND POBLACIONS.cod_m=INSTITUTS.cod_m GROUP BY COMARQUES.nom_c, provincia; De forma general, si tenim n taules en una consulta, ens faran falta n-1 condicions de combinaci\u00f3 unides per AND. Per exemple, si en una consulta entren 5 taules, per a no tenir cap producte cartesi\u00e0 ens faran falta 4 condicions unides per AND. Una taula m\u00e9s d'una vegada Anem a plantejar un altre exemple interessant: traure el nom de les poblacions, amb el nom de la capital de comarca. Lamentablement amb les dades que tenim en la Base de Dades d'exemple no podrem provar-lo, aix\u00ed que anem a fer una suposici\u00f3, una Base de Dades lleugerament modificada per a il\u00b7lustrar aquest exemple. Suposem que la nostra taula de POBLACIONS f\u00f3ra lleugerament diferent, i que incorporara un camp nou amb el codi del municipi que \u00e9s capital de comarca de la poblaci\u00f3: POBLACIONS ( cod_m numeric(5,0) CONSTRAINT cp_pobl PRIMARY KEY, nom character varying(50) NOT NULL, poblacio numeric(6,0), extensio numeric(6,2), altura numeric(4,0), longitud character varying(50), latitud character varying(50), llengua character(1), nom_c character varying(50), ***cod_capital numeric(5,0) CONSTRAINT ce_capital REFERENCES POBLACIONS(cod_m) ) Per a poder traure al mateix temps el nom de les poblacions i el nom de la seua capital de comarca no tenim prou amb posar la taula POBLACIONS una vegada: nom\u00e9s traur\u00edem el nom de la poblaci\u00f3 i ens quedar\u00edem amb el codi de municipi de la capital. La soluci\u00f3 ser\u00e0 reunir-la amb la taula POBLACIONS, posant-la una segona vegada per a tenir dues inst\u00e0ncies de la taula, una inst\u00e0ncia per al poblaci\u00f3 normal i una altra per a la capital. Per\u00f2 com distingirem entre les dues inst\u00e0ncies? Doncs posant un nom a cadascuna. En general podem posar un nom en la sent\u00e8ncia a qualsevol taula que aparega, posant aquest nom a continuaci\u00f3 de la taula (opcionalment podr\u00edem posar AS enmig): SELECT ... FROM taula T En la resta de la consulta haurem d'utilitzar aquest nom. L'exemple quedar\u00e0 de la seg\u00fcent manera: SELECT P1.nom AS \"Nom poblaci\u00f3\" , P2.nom as \"Nom capital\" FROM POBLACIONS P1 INNER JOIN POBLACIONS P2 ON P1.cod_capital=P2.cod_m o de la forma alternativa: SELECT P1.nom AS \"Nom poblaci\u00f3\" , P2.nom as \"Nom capital\" FROM POBLACIONS P1, POBLACIONS P2 WHERE P1.cod_capital=P2.cod_m Nota Recordeu que aquestes instruccions no les podem provar, perqu\u00e8 no tenim el camp cod_capital . Clau externa formada per m\u00e9s d'un camp Per \u00faltim anem a considerar el cas que la clau externa estiga formada per m\u00e9s d'un camp. Ho basarem en l'exemple dels Bancs , on la taula COMPTE CORRENT dep\u00e8n en identificaci\u00f3 de SUCURSAL. Com la clau principal de SUCURSAL est\u00e0 formada per 2 camps, la clau externa de COMPTE CORRENT, que apunta a la primera tamb\u00e9 estar\u00e0 formada per 2 camps. Si volem traure el n\u00famero de compte corrent, el nom de la sucursal d'on \u00e9s el compte, i el saldo, ens faran falta les dues taules. Aquesta seria la manera de combinar-les: SELECT C.n_ent , C.n_suc , n_cc , S.nom , C.saldo FROM SUCURSAL S INNER JOIN COMPTE_CORRENT C ON S.n_ent=C.n_ent AND S.n_suc=C.n_suc o de la forma alternativa: SELECT C.n_ent , C.n_suc , n_cc , S.nom , C.saldo FROM SUCURSAL S, COMPTE_CORRENT C WHERE S.n_ent=C.n_ent AND S.n_suc=C.n_suc En ambd\u00f3s casos s'ha optat per posar nom a les taules (S i C respectivament) per comoditat, per a que no quedara tan llarga la consulta. Exercicis Ex_51 Traure el nom dels clients amb el n\u00famero de factura i la data (individuals, sense agrupar res) que t\u00e9 cada client. Trau el resultat ordenat per client, i dins d'aquest per data de la factura Ex_52 Traure el nom del soci, amb el codi i la descripci\u00f3 de cada article que ha demanat. Ordena per nom del soci i codi de l'article. Ex_53 Modificar l'anterior per a que no es repetesquen els resultats. Ex_54 Traure el nom dels clients amb la quantitat de factures que tenen, ordenades per aquest n\u00famero de major a menor Ex_55 Traure el n\u00famero de factura, data, codi de client, total de la factura (amb l'\u00e0lies IMPORT) i total de la factura aplicant descomptes d'article (amb \u00e0lies DESCOMPTE_1), com en la consulta Ex_33 , per\u00f2 sense el l\u00edmit de les 10 l\u00ednies de factura. Ordena per n\u00famero de factura. Ex_56 Modificar l'anterior per a aplicar tamb\u00e9 el descompte de la factura (amb l'\u00e0lies DESCOMPTE_2) Ex_57 Traure el codi i nom d'aquells venedors que supervisen alg\u00fa (consten com a cap). Traure tamb\u00e9 el n\u00famero de supervisats de cadascun d'aquestos supervisors. Ex_58 Traure el codi i descripci\u00f3 dels articles juntament amb el n\u00famero de vegades que s'ha venut, el total d'unitats venudes i la mitjana d'unitats venudes per factura. Ex_59 Traure el codi i la descripci\u00f3 de les categories, amb la quantitat d'articles venuts de cada categoria, d'aquelles categories de les quals se n'han venut m\u00e9s de 100 unitats. Ordenar per aquest n\u00famero de forma decendent. 2.3 Combinaci\u00f3 externa En ocasions ens interessar\u00e0 fer una combinaci\u00f3 diferent. Com quasi sempre ens basarem en un exemple. Quan en un exemple del punt anterior tra\u00edem els nom de les poblacions amb el nom dels instituts, no podien eixir les poblacions que no tenen instituts. Ara ens plantejarem la possibilitat de traure totes les poblacions, fins i tot aquelles que no tenen instituts, per\u00f2 d'aquelles que s\u00ed que en tinguen traure tamb\u00e9 el nom dels instituts. Aquesta operaci\u00f3 s'anomena COMBINACI\u00d3 EXTERNA . Sintaxi Tindrem dues possibilitats: traure totes les de l'esquerra o traure totes les de la dreta. Per a traure TOTES les files de la taula de l'esquerra, i aquelles que estiguen relacionades de la de la dreta: SELECT ... FROM taula1 LEFT [OUTER] JOIN taula2 ON _condici\u00f3_ Aix\u00ed traurem TOTES les files de taula1, i aquelles que estiguen relacionades de taula2. Per a fer-ho al rev\u00e8s, \u00e9s a dir, totes les files de la taula de la dreta i aquelles files que estiguen relacionades de l'esquerra: SELECT ... FROM taula1 RIGHT [OUTER] JOIN taula2 ON _condici\u00f3_ D'aquesta manera traurem TOTES les files de taula2, i aquelles que estiguen relacionades de taula1. En el nostre exemple: SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS LEFT JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m ORDER BY 1 on hem ordenat pel nom de la poblaci\u00f3 per a una millor lectura, i ens donar\u00e0 el seg\u00fcent resultat: Podem observar que ens trau fins i tot els pobles que no tenen instituts, i que en el camp nom de l'institut tenen el valor NULL. Fem una variant interessant. Anem a traure els pobles amb el nombre d'instituts que t\u00e9 cadascun. Ens far\u00e0 falta la taula POBLACIONS per a poder traure el nom de la poblaci\u00f3 i la taula INSTITUTS per a traure el nombre d'instituts, i agruparem pel nom de la poblaci\u00f3. Les dues taules les hem de combinar (per evitar el producte cartesi\u00e0). Si fem una combinaci\u00f3 normal (interna), els que no tenen instituts no entren . Per\u00f2 si fem una combinaci\u00f3 externa s\u00ed que entraran . Nom\u00e9s ens queda comptar per un camp que en el cas dels que no tenen instituts tinga el valor nul, \u00e9s a dir, per un camp de la taula INSTITUTS, i el que millor se'ns acopla \u00e9s algun que forma part de la clau principal, ja que com no pot agafar un valor nul en la taula INSTITUTS, l'\u00fanica possibilitat que agafe el valor nul en la combinaci\u00f3 externa \u00e9s que la poblaci\u00f3 no tinga institut, i aleshores en el moment de comptar ens donar\u00e0 el valor 0. Aquesta ser\u00e0 la consulta, on hem tornat a ordenar pel nom de la poblaci\u00f3 SELECT POBLACIONS.nom,COUNT(INSTITUTS.codi) FROM POBLACIONS LEFT JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m GROUP BY POBLACIONS.nom ORDER BY 1 I aquest ser\u00e0 el resultat Una altra variant tamb\u00e9 interessant \u00e9s fer una consulta similar per a traure els pobles que no tenen institut. Haurem de fer una combinaci\u00f3 externa, i en la condici\u00f3 posar justament que un dels camps de la taula INSTITUTS siga nul (per exemple, la clau principal): Aquesta ser\u00e0 la consulta, on hem tornat a ordenar pel nom de la poblaci\u00f3: SELECT POBLACIONS.nom FROM POBLACIONS LEFT JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m WHERE INSTITUTS.codi IS NULL ORDER BY 1 I aquest ser\u00e0 el resultat: Exemples 1) Traure totes les comarques amb el n\u00famero de pobles que t\u00e9 cadascuna, fins i tot aquelles comarques que no tinguen cap poble. Aquest exemple \u00e9s poc il\u00b7lustratiu, perqu\u00e8 no tenim en principi cap camarca que no tinga pobles. De tota manera, la manera seria fent un LEFT JOIN entre COMARQUES i POBLACIONS, per a despr\u00e9s agrupar per comarca i comptar les poblacions. Observeu com tamb\u00e9 podem utilitzar la sintaxi del USING en el LEFT JOIN. SELECT COMARQUES.nom_c, COUNT(cod_m) FROM COMARQUES LEFT JOIN POBLACIONS USING(nom_c) GROUP BY COMARQUES.nom_c ORDER BY 1; Exercicis Ex_60 Traure el codi i el nom dels clients que no tenen cap factura. Ex_61 Traure el codi, descripci\u00f3 i total d'unitats venudes de tots els articles, fins i tot d'aquells que no s'ha venut res. Nota Per a deixar-lo m\u00e9s bonic, com que la suma de valors nuls no \u00e9s 0 sin\u00f3 nul, per a que ens aparegue el valor 0 podem utilitzar la funci\u00f3 COALESCE( valor ,0), que si el valor \u00e9s nul torna un 0. Ex_62 Traure el nom de tots els pobles i el n\u00famero de clients en cas de que en tinguen. Ordena per n\u00famero de clients de forma descendent. Ex_63 Traure el codi i la descripci\u00f3 de les categories, amb el n\u00famero d'articles de cada categoria i el n\u00famero total d'unitats venudes de cada categoria, d'aquelles categories de les quals tenim m\u00e9s de 15 articles, i ordenat per n\u00famero d'articles de forma descendent. Aquesta sent\u00e8ncia ja \u00e9s prou complicada. Concretament haureu de tenir en compte que: Voldrem traure el n\u00famero d'articles de cada categoria, per\u00f2 potser alguns articles no s'han venut, i per tant no apareixeran en la taula LINIA_FAC. I tamb\u00e9 tenim el problema que, com ens fa falta la taula LINIA_FAC, un article venut en m\u00e9s d'una factura apareixer\u00e0 m\u00e9s d'una vegada. Si comptem de forma normal, el comptar\u00edem m\u00e9s d'una vegada cada article. Per tant voldrem comptar els diferents articles de cada categoria. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"2. Combinacions de taules"},{"location":"BD_PostgreSQL_DQL_Avancat/22_combinacions_de_taules/#2-combinacions-de-taules","text":"Vam veure en la sent\u00e8ncia b\u00e0sica que en la cl\u00e0usula FROM pos\u00e0vem la taula o taules d'on s'agafarien les dades, per\u00f2 en tots els exemples posteriors nom\u00e9s entrava en joc una \u00fanica taula. \u00c9s el moment d'estudiar les diferents possibilitats que tindrem quan posem m\u00e9s d'una taula. La primera \u00e9s el producte cartesi\u00e0 , que no utilitzarem mai, per\u00f2 hem de saber en qu\u00e8 consisteix per poder evitar-lo. La segona ser\u00e0 la m\u00e9s utilitzada, la combinaci\u00f3 (que de vegades anomenarem reuni\u00f3 ). La tercera \u00e9s una variant de l'anterior, la combinaci\u00f3 externa , molt \u00fatil en alguns casos.","title":"2 Combinacions de taules"},{"location":"BD_PostgreSQL_DQL_Avancat/22_combinacions_de_taules/#21-producte-cartesia","text":"La manera m\u00e9s senzilla \u00e9s posar les taules separades per comes, per\u00f2 segurament el resultat no \u00e9s el que esper\u00e0vem. Per exemple podem fer la seg\u00fcent sent\u00e8ncia: SELECT COMARQUES.nom_c, nom FROM COMARQUES,POBLACIONS; Nota Observeu que hem posat el nom de la taula davant del camp nom_c , perqu\u00e8 les dues taules tenen un camp amb aquest nom. Aquesta operaci\u00f3 s'anomena qualificaci\u00f3 . Si no qualific\u00e0rem amb el nom de la taula davant, hi hauria ambig\u00fcitat, no sabria a quin camp es refereix, si el d'una taula o el de l'altra. Quan els noms dels camps s\u00f3n diferents i per tant no coincideixen en les dues taules, no cal qualificar el camp (com per exemple amb el camp nom ) Si executem la sent\u00e8ncia, veurem que tindrem un nombre de files inesperadament alt, 18.428 files !!! I si analitzem les files veurem el perqu\u00e8: s'ha combinat cada comarca amb tots els pobles (siguen de la comarca o no). Aquesta operaci\u00f3 s'anomena PRODUCTE CARTESI\u00c0 ( cross join ), i es caracteritza en qu\u00e8 cadascuna de les files d'una taula es combina amb totes les files de l'altra taula. El nombre de files resultant ser\u00e0, doncs, el resultat de multiplicar el nombre de files d'una taula pel nombre de files de l'altra taula (en el nostre cas 34 x 542 = 18428). Rarament voldrem fer un producte cartesi\u00e0. El m\u00e9s normal ser\u00e0 combinar una miqueta millor les taules. En el nostre exemple segurament ens interessar\u00e0 molt m\u00e9s combinar cada comarca amb les seues poblacions .","title":"2.1 Producte cartesi\u00e0"},{"location":"BD_PostgreSQL_DQL_Avancat/22_combinacions_de_taules/#22-combinacio-interna","text":"Combinaci\u00f3 de dues taules: Sintaxi Normalment el producte cartesi\u00e0 no ens interessar\u00e0. M\u00e9s b\u00e9 voldrem combinar les taules de manera que dos camps, un camp de cada taula, coincidesquen. I el m\u00e9s habitual, si tenim la Base de Dades ben dissenyada, ser\u00e0 que els camps coincidents siguen una clau externa amb la clau principal a la qual apunta. Aix\u00ed, en l'exemple que utilitz\u00e0vem en el punt anterior, el que s\u00ed que ens ser\u00e0 \u00fatil \u00e9s combinar cada comarca amb les seues poblacions. I justament tenim un camp en la taula POBLACIONS, nom_c , que \u00e9s clau externa i apunta a la clau principal de COMARQUES . Aquesta operaci\u00f3 l'anomenarem COMBINACI\u00d3 INTERNA o senzillament COMBINACI\u00d3 , i de vegades tamb\u00e9 es diu REUNI\u00d3 . La seua sintaxi \u00e9s la seg\u00fcent: SELECT ... FROM taula1 INNER JOIN taula2 ON _condici\u00f3_ La condici\u00f3 de la reuni\u00f3 consistir\u00e0 en comparar un camp de cada taula. Els dos camps hauran de ser del mateix tipus, per\u00f2 no caldr\u00e0 que tinguen el mateix nom. Les files que eixiran al resultat seran les que acompliran la condici\u00f3. Encara que els operadors que es poden utilitzar s\u00f3n tots els de comparaci\u00f3, en la pr\u00e0ctica SEMPRE utilitzarem el d'igualar. Per tant podem refinar millor la combinaci\u00f3 de 2 taules SELECT ... FROM taula1 INNER JOIN taula2 ON taula1.camp1 = taula2.camp2 L'exemple de les comarques i les seues poblacions quedar\u00e0 aix\u00ed SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c = POBLACIONS.nom_c I aquest seria el resultat que com veiem torna 542 files (tantes com pobles) Alternativament, podr\u00edem posar la mateixa reuni\u00f3 d'una altra forma: SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES,POBLACIONS WHERE COMARQUES.nom_c = POBLACIONS.nom_c on estrictament el que estem fent \u00e9s, del producte cartesi\u00e0 de les 2 taules, seleccionar \u00fanicament quan coincideix el nom_c (\u00e9s a dir la comarca amb les seues poblacions), i per tant el resultat seria el mateix. Potser f\u00f3ra m\u00e9s eficient utilitzar la primera manera, per\u00f2 de vegades la comoditat ens far\u00e0 utilitzar la segona (sobretot quan s'hagen de combinar moltes taules). Les dues maneres de posar la conbinaci\u00f3 de dues taules s\u00f3n les m\u00e9s habituals, i que funcionen en qualsevol Sistema Gestor de Bases de Dades. Tanmateix en PostgreSQL (i en altres SGBD com Oracle) hi ha m\u00e9s maneres de fer una combinaci\u00f3. No les veurem tan a fons perqu\u00e8 les anteriors ens basten i sobren: INNER JOIN amb USING : En el cas que els camps a reunir de les dues taules es diguen exactament igual, podem substituir la condici\u00f3 posada en ON per l'expressi\u00f3 USING , amb el camp de la reuni\u00f3 entre par\u00e8ntesis SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) NATURAL JOIN : Tamb\u00e9 per al cas anterior, en qu\u00e8 el camp en les dues taules es diu igual, podem fer-lo de forma encara m\u00e9s abreviada. Far\u00e0 una reuni\u00f3, igualant tots els camps que es diguen igual de les dues taules. Hem d'anar en compte, per si de cas hi ha algun altre camp en les dues taules que es diga igual. SELECT COMARQUES.nom_c, POBLACIONS.nom FROM COMARQUES NATURAL JOIN POBLACIONS Exemples 1) Traure el noms de les Poblacions i els noms dels Instituts que hi ha en elles. Haurem de combinar les taules per la clau externa d'INSTITUTS a POBLACIONS (\u00e9s a dir la que apunta de cod_m en INSTITUTS fins a la clau principal de COMARQUES, que \u00e9s justament cod_m). SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS INNER JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m; Utilitzant l'altra sintaxi, que posem la condici\u00f3 en el WHERE , ens quedaria: SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS , INSTITUTS WHERE POBLACIONS.cod_m=INSTITUTS.cod_m; Com en aquest cas el camp que hem d'igualar t\u00e9 el mateix nom en les dues taules, utilitzant la sintaxi del USING ens quedari m\u00e9s f\u00e0cil: SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS INNER JOIN INSTITUTS USING(cod_m); En canvi, hem d'anar amb molt de compte amb la sintaxi del NATURAL JOIN , perqu\u00e8 itentar\u00e0 igualar tots els camps que es diuen igual, i en aquest cas tenim dos camps coincidents: cod_m i nom. cod_m \u00e9s el que volem, per\u00f2 nom ens fastidiar\u00e0, i evidentment no coincideix mai el nom de l'Institut i el de la poblaci\u00f3, i per tant no tornar\u00e0 cap fila. SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS NATURAL JOIN INSTITUTS; 2) Traure els noms de les comarques i la prov\u00edncia, amb el nombre de poblacions que t\u00e9 cada comarca. Ens fan falta dues taules, COMARQUES per a poder traure el nom de la comarca i la prov\u00edncia, i POBLACIONS per a poder comptar els pobles de cada comarca. Les haurem de combinar, agrupar per comarca (i prov\u00edncia tamb\u00e9, perqu\u00e8 volem que aparega el nom de la prov\u00edncia) i comptar les poblacions. A l'hora de comptar podem comptar files (COUNT(*)), per\u00f2 potser siga millor comptar algun camp de la taula POBLACIONS, per exemple cod_m, que \u00e9s la clau principal (recordem que els valors nuls no es comptaran, i cod_m per ser clau principal no pot ser nul). SELECT COMARQUES.nom_c, provincia, COUNT(cod_m) AS Quants FROM COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c GROUP BY COMARQUES.nom_c, provincia; Tres o m\u00e9s taules Si tenim m\u00e9s de 2 taules, haurem de procedir de la mateixa manera, ja que si deixem de combinar alguna taula, tindrem el producte cartesi\u00e0. Com en la immensa majoria de casos, la reuni\u00f3 la farem per les claus externes que tenim definides. \u00danicament haurem de cuidar els par\u00e8ntesis, per a marcar primer una condici\u00f3 de combinaci\u00f3 i despr\u00e9s l'altra. En un exemple ho veurem perfectament il\u00b7lustrat. Intentem traure el nom d'una comarca i la prov\u00edncia, el nom dels seus pobles i el nom dels instituts d'aquestos pobles. Ens fan falta les taules COMARQUES (pera poder traure el nom de la comarca i prov\u00edncia), POBLACIONS (per a traure el nom de la poblaci\u00f3) i INSTITUTS (per al nom d'aquestos). Ordenarem per nom de comarca, i dins d'aquest per poblaci\u00f3, per a una millor lectura del resultat SELECT COMARQUES.nom_c, provincia, POBLACIONS.nom, INSTITUTS.nom FROM (COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c) INNER JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m ORDER BY 1,3; Podr\u00edem posar la consulta de la forma alternativa, en qu\u00e8 les condicions de reuni\u00f3 van en el WHERE. \u00d2bviament aquestes condicions han d'anar unides per l'operador AND. SELECT COMARQUES.nom_c, provincia, POBLACIONS.nom, INSTITUTS.nom FROM COMARQUES , POBLACIONS , INSTITUTS WHERE COMARQUES.nom_c=POBLACIONS.nom_c AND POBLACIONS.cod_m=INSTITUTS.cod_m ORDER BY 1,3; Anem a plantejar un altre exemple. Es tracta de traure el nom i la prov\u00edncia de les comarques, amb el n\u00famero d'Instituts que hi ha en elles. En principi podr\u00edem pensar que les \u00faniques taules que ens fan falta s\u00f3n COMARQUES (per a traure el nom i prov\u00edncia de la comarca) i INSTITUTS (per a poder comptar els INSTITUTS). Si intentem fer aquesta consulta, NO obtindrem el resultat desitjat. Aviso SELECT nom_c, provincia, COUNT(codi) FROM COMARQUES , INSTITUTS) GROUP BY nom_c, provincia) Evidentment hi haur\u00e0 un producte cartesi\u00e0, ja que no hem combinat les taules, i ens eixir\u00e0 per a cada comarca 375 instituts, que \u00e9s el n\u00famero total d'instituts, ja que s'ha combinat cada comarca amb tots els instituts. Per\u00f2 aleshores, per quin camp combinem? Si intentem unir les claus principals, nom_c amb codi (el codi d'Institut) no poden combinar b\u00e9 per raons evidents. Ens hem de fixar en el disseny de la Base de Dades. Observarem que el problema \u00e9s que no hi ha una clau externa entre INSTITUTS i COMARQUES. Per\u00f2 tamb\u00e9 ens d\u00f3na la soluci\u00f3: haurem de posar tamb\u00e9 la taula POBLACIONS encara que no vulguem visualitzar cap camp d'aquesta taula, ja que si estan relacionades les taules INSTITUTS i COMARQUES \u00e9s a trav\u00e9s d'aquesta taula. Per tant la consulta correcta ser\u00e0: SELECT COMARQUES.nom_c, provincia, COUNT(codi) FROM (COMARQUES INNER JOIN POBLACIONS ON COMARQUES.nom_c=POBLACIONS.nom_c) INNER JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m GROUP BY COMARQUES.nom_c, provincia La forma alternativa sembla m\u00e9s curta. Est\u00e0 clar que si s\u00f3n 3 taules, hauran d'haver 2 condicions de combinaci\u00f3 unides per AND. SELECT COMARQUES.nom_c, provincia, COUNT(codi) FROM COMARQUES , POBLACIONS , INSTITUTS WHERE COMARQUES.nom_c=POBLACIONS.nom_c AND POBLACIONS.cod_m=INSTITUTS.cod_m GROUP BY COMARQUES.nom_c, provincia; De forma general, si tenim n taules en una consulta, ens faran falta n-1 condicions de combinaci\u00f3 unides per AND. Per exemple, si en una consulta entren 5 taules, per a no tenir cap producte cartesi\u00e0 ens faran falta 4 condicions unides per AND. Una taula m\u00e9s d'una vegada Anem a plantejar un altre exemple interessant: traure el nom de les poblacions, amb el nom de la capital de comarca. Lamentablement amb les dades que tenim en la Base de Dades d'exemple no podrem provar-lo, aix\u00ed que anem a fer una suposici\u00f3, una Base de Dades lleugerament modificada per a il\u00b7lustrar aquest exemple. Suposem que la nostra taula de POBLACIONS f\u00f3ra lleugerament diferent, i que incorporara un camp nou amb el codi del municipi que \u00e9s capital de comarca de la poblaci\u00f3: POBLACIONS ( cod_m numeric(5,0) CONSTRAINT cp_pobl PRIMARY KEY, nom character varying(50) NOT NULL, poblacio numeric(6,0), extensio numeric(6,2), altura numeric(4,0), longitud character varying(50), latitud character varying(50), llengua character(1), nom_c character varying(50), ***cod_capital numeric(5,0) CONSTRAINT ce_capital REFERENCES POBLACIONS(cod_m) ) Per a poder traure al mateix temps el nom de les poblacions i el nom de la seua capital de comarca no tenim prou amb posar la taula POBLACIONS una vegada: nom\u00e9s traur\u00edem el nom de la poblaci\u00f3 i ens quedar\u00edem amb el codi de municipi de la capital. La soluci\u00f3 ser\u00e0 reunir-la amb la taula POBLACIONS, posant-la una segona vegada per a tenir dues inst\u00e0ncies de la taula, una inst\u00e0ncia per al poblaci\u00f3 normal i una altra per a la capital. Per\u00f2 com distingirem entre les dues inst\u00e0ncies? Doncs posant un nom a cadascuna. En general podem posar un nom en la sent\u00e8ncia a qualsevol taula que aparega, posant aquest nom a continuaci\u00f3 de la taula (opcionalment podr\u00edem posar AS enmig): SELECT ... FROM taula T En la resta de la consulta haurem d'utilitzar aquest nom. L'exemple quedar\u00e0 de la seg\u00fcent manera: SELECT P1.nom AS \"Nom poblaci\u00f3\" , P2.nom as \"Nom capital\" FROM POBLACIONS P1 INNER JOIN POBLACIONS P2 ON P1.cod_capital=P2.cod_m o de la forma alternativa: SELECT P1.nom AS \"Nom poblaci\u00f3\" , P2.nom as \"Nom capital\" FROM POBLACIONS P1, POBLACIONS P2 WHERE P1.cod_capital=P2.cod_m Nota Recordeu que aquestes instruccions no les podem provar, perqu\u00e8 no tenim el camp cod_capital . Clau externa formada per m\u00e9s d'un camp Per \u00faltim anem a considerar el cas que la clau externa estiga formada per m\u00e9s d'un camp. Ho basarem en l'exemple dels Bancs , on la taula COMPTE CORRENT dep\u00e8n en identificaci\u00f3 de SUCURSAL. Com la clau principal de SUCURSAL est\u00e0 formada per 2 camps, la clau externa de COMPTE CORRENT, que apunta a la primera tamb\u00e9 estar\u00e0 formada per 2 camps. Si volem traure el n\u00famero de compte corrent, el nom de la sucursal d'on \u00e9s el compte, i el saldo, ens faran falta les dues taules. Aquesta seria la manera de combinar-les: SELECT C.n_ent , C.n_suc , n_cc , S.nom , C.saldo FROM SUCURSAL S INNER JOIN COMPTE_CORRENT C ON S.n_ent=C.n_ent AND S.n_suc=C.n_suc o de la forma alternativa: SELECT C.n_ent , C.n_suc , n_cc , S.nom , C.saldo FROM SUCURSAL S, COMPTE_CORRENT C WHERE S.n_ent=C.n_ent AND S.n_suc=C.n_suc En ambd\u00f3s casos s'ha optat per posar nom a les taules (S i C respectivament) per comoditat, per a que no quedara tan llarga la consulta.","title":"2.2 Combinaci\u00f3 interna"},{"location":"BD_PostgreSQL_DQL_Avancat/22_combinacions_de_taules/#exercicis","text":"Ex_51 Traure el nom dels clients amb el n\u00famero de factura i la data (individuals, sense agrupar res) que t\u00e9 cada client. Trau el resultat ordenat per client, i dins d'aquest per data de la factura Ex_52 Traure el nom del soci, amb el codi i la descripci\u00f3 de cada article que ha demanat. Ordena per nom del soci i codi de l'article. Ex_53 Modificar l'anterior per a que no es repetesquen els resultats. Ex_54 Traure el nom dels clients amb la quantitat de factures que tenen, ordenades per aquest n\u00famero de major a menor Ex_55 Traure el n\u00famero de factura, data, codi de client, total de la factura (amb l'\u00e0lies IMPORT) i total de la factura aplicant descomptes d'article (amb \u00e0lies DESCOMPTE_1), com en la consulta Ex_33 , per\u00f2 sense el l\u00edmit de les 10 l\u00ednies de factura. Ordena per n\u00famero de factura. Ex_56 Modificar l'anterior per a aplicar tamb\u00e9 el descompte de la factura (amb l'\u00e0lies DESCOMPTE_2) Ex_57 Traure el codi i nom d'aquells venedors que supervisen alg\u00fa (consten com a cap). Traure tamb\u00e9 el n\u00famero de supervisats de cadascun d'aquestos supervisors. Ex_58 Traure el codi i descripci\u00f3 dels articles juntament amb el n\u00famero de vegades que s'ha venut, el total d'unitats venudes i la mitjana d'unitats venudes per factura. Ex_59 Traure el codi i la descripci\u00f3 de les categories, amb la quantitat d'articles venuts de cada categoria, d'aquelles categories de les quals se n'han venut m\u00e9s de 100 unitats. Ordenar per aquest n\u00famero de forma decendent.","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL_Avancat/22_combinacions_de_taules/#23-combinacio-externa","text":"En ocasions ens interessar\u00e0 fer una combinaci\u00f3 diferent. Com quasi sempre ens basarem en un exemple. Quan en un exemple del punt anterior tra\u00edem els nom de les poblacions amb el nom dels instituts, no podien eixir les poblacions que no tenen instituts. Ara ens plantejarem la possibilitat de traure totes les poblacions, fins i tot aquelles que no tenen instituts, per\u00f2 d'aquelles que s\u00ed que en tinguen traure tamb\u00e9 el nom dels instituts. Aquesta operaci\u00f3 s'anomena COMBINACI\u00d3 EXTERNA . Sintaxi Tindrem dues possibilitats: traure totes les de l'esquerra o traure totes les de la dreta. Per a traure TOTES les files de la taula de l'esquerra, i aquelles que estiguen relacionades de la de la dreta: SELECT ... FROM taula1 LEFT [OUTER] JOIN taula2 ON _condici\u00f3_ Aix\u00ed traurem TOTES les files de taula1, i aquelles que estiguen relacionades de taula2. Per a fer-ho al rev\u00e8s, \u00e9s a dir, totes les files de la taula de la dreta i aquelles files que estiguen relacionades de l'esquerra: SELECT ... FROM taula1 RIGHT [OUTER] JOIN taula2 ON _condici\u00f3_ D'aquesta manera traurem TOTES les files de taula2, i aquelles que estiguen relacionades de taula1. En el nostre exemple: SELECT POBLACIONS.nom,INSTITUTS.nom FROM POBLACIONS LEFT JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m ORDER BY 1 on hem ordenat pel nom de la poblaci\u00f3 per a una millor lectura, i ens donar\u00e0 el seg\u00fcent resultat: Podem observar que ens trau fins i tot els pobles que no tenen instituts, i que en el camp nom de l'institut tenen el valor NULL. Fem una variant interessant. Anem a traure els pobles amb el nombre d'instituts que t\u00e9 cadascun. Ens far\u00e0 falta la taula POBLACIONS per a poder traure el nom de la poblaci\u00f3 i la taula INSTITUTS per a traure el nombre d'instituts, i agruparem pel nom de la poblaci\u00f3. Les dues taules les hem de combinar (per evitar el producte cartesi\u00e0). Si fem una combinaci\u00f3 normal (interna), els que no tenen instituts no entren . Per\u00f2 si fem una combinaci\u00f3 externa s\u00ed que entraran . Nom\u00e9s ens queda comptar per un camp que en el cas dels que no tenen instituts tinga el valor nul, \u00e9s a dir, per un camp de la taula INSTITUTS, i el que millor se'ns acopla \u00e9s algun que forma part de la clau principal, ja que com no pot agafar un valor nul en la taula INSTITUTS, l'\u00fanica possibilitat que agafe el valor nul en la combinaci\u00f3 externa \u00e9s que la poblaci\u00f3 no tinga institut, i aleshores en el moment de comptar ens donar\u00e0 el valor 0. Aquesta ser\u00e0 la consulta, on hem tornat a ordenar pel nom de la poblaci\u00f3 SELECT POBLACIONS.nom,COUNT(INSTITUTS.codi) FROM POBLACIONS LEFT JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m GROUP BY POBLACIONS.nom ORDER BY 1 I aquest ser\u00e0 el resultat Una altra variant tamb\u00e9 interessant \u00e9s fer una consulta similar per a traure els pobles que no tenen institut. Haurem de fer una combinaci\u00f3 externa, i en la condici\u00f3 posar justament que un dels camps de la taula INSTITUTS siga nul (per exemple, la clau principal): Aquesta ser\u00e0 la consulta, on hem tornat a ordenar pel nom de la poblaci\u00f3: SELECT POBLACIONS.nom FROM POBLACIONS LEFT JOIN INSTITUTS ON POBLACIONS.cod_m=INSTITUTS.cod_m WHERE INSTITUTS.codi IS NULL ORDER BY 1 I aquest ser\u00e0 el resultat: Exemples 1) Traure totes les comarques amb el n\u00famero de pobles que t\u00e9 cadascuna, fins i tot aquelles comarques que no tinguen cap poble. Aquest exemple \u00e9s poc il\u00b7lustratiu, perqu\u00e8 no tenim en principi cap camarca que no tinga pobles. De tota manera, la manera seria fent un LEFT JOIN entre COMARQUES i POBLACIONS, per a despr\u00e9s agrupar per comarca i comptar les poblacions. Observeu com tamb\u00e9 podem utilitzar la sintaxi del USING en el LEFT JOIN. SELECT COMARQUES.nom_c, COUNT(cod_m) FROM COMARQUES LEFT JOIN POBLACIONS USING(nom_c) GROUP BY COMARQUES.nom_c ORDER BY 1;","title":"2.3 Combinaci\u00f3 externa"},{"location":"BD_PostgreSQL_DQL_Avancat/22_combinacions_de_taules/#exercicis_1","text":"Ex_60 Traure el codi i el nom dels clients que no tenen cap factura. Ex_61 Traure el codi, descripci\u00f3 i total d'unitats venudes de tots els articles, fins i tot d'aquells que no s'ha venut res. Nota Per a deixar-lo m\u00e9s bonic, com que la suma de valors nuls no \u00e9s 0 sin\u00f3 nul, per a que ens aparegue el valor 0 podem utilitzar la funci\u00f3 COALESCE( valor ,0), que si el valor \u00e9s nul torna un 0. Ex_62 Traure el nom de tots els pobles i el n\u00famero de clients en cas de que en tinguen. Ordena per n\u00famero de clients de forma descendent. Ex_63 Traure el codi i la descripci\u00f3 de les categories, amb el n\u00famero d'articles de cada categoria i el n\u00famero total d'unitats venudes de cada categoria, d'aquelles categories de les quals tenim m\u00e9s de 15 articles, i ordenat per n\u00famero d'articles de forma descendent. Aquesta sent\u00e8ncia ja \u00e9s prou complicada. Concretament haureu de tenir en compte que: Voldrem traure el n\u00famero d'articles de cada categoria, per\u00f2 potser alguns articles no s'han venut, i per tant no apareixeran en la taula LINIA_FAC. I tamb\u00e9 tenim el problema que, com ens fa falta la taula LINIA_FAC, un article venut en m\u00e9s d'una factura apareixer\u00e0 m\u00e9s d'una vegada. Si comptem de forma normal, el comptar\u00edem m\u00e9s d'una vegada cada article. Per tant voldrem comptar els diferents articles de cada categoria. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL_Avancat/23_subconsultes/","text":"3 Subconsultes Una subconsulta \u00e9s una consulta dins d'una altra consulta. Aquesta subconsulta pot tenir tots els elements que hem vist fins ara. El lloc on posar una subconsulta dins de la consulta principal pot ser en la cl\u00e0usual WHERE o en la cl\u00e0usula HAVING (formant part d'una condici\u00f3) o en el FROM, i ha d'anar entre par\u00e8ntesis. Fins i tot es pot posar en el mateix SELECT, \u00e9s a dir, en les columnes que van despr\u00e9s del SELECT. Si va en el FROM , la subconsulta ser\u00e0 l'origen de les dades, i per tant s'executar\u00e0 abans i proporcionar\u00e0 les dades per a la consulta principal. Si va en el WHERE o el HAVING formar\u00e0 part d'una condici\u00f3, i aix\u00ed podrem comparar en la consulta principal un camp amb el que torne la subconsulta, per exemple. A banda de les comparacions normals que ja hem vist en el WHERE o el HAVING, podrem posar alguns operadors i predicats especials, com veurem m\u00e9s avant. Si va en el mateix SELECT normalment ser\u00e0 per a traure un resultat global que no afecta a la resta de la consulta 3.1 Sintaxi en el FROM SELECT ... FROM ( _Subconsulta_) AS _Nom_Subconsulta_ Anem a posar un exemple per entendre-ho. Volem traure la mitjana de pobles per comarca. Ho podem fer de la seg\u00fcent manera: primer comptem quants pobles hi ha en cada comarca, i una vegada calculat aix\u00f2 traem la mitjana. SELECT AVG(quants) FROM (SELECT COUNT(*) AS quants FROM POBLACIONS GROUP BY nom_c) AS S ; Observeu que \u00e9s necessari posar-li un \u00e0lias a la columna de la subconsulta (quants) per a poder fer refer\u00e8ncia a ella en la consulta principal. I per una altra banda, en PostgreSQL les subconsultes que van al FROM han de tenir obligat\u00f2riament un \u00e0lies. Si no pos\u00e0rem ... AS S (o qualsevol altre nom) ens donaria error. Com veieu, ja t\u00e9 un nivell de complexitat m\u00e9s que acceptable. Sempre s'executa primer la subconsulta i amb les dades que proporciona, s'executa la consulta principal. Pel grau de complexitat \u00e9s molt recomanable anar de dins cap a fora, \u00e9s a dir, pensar b\u00e9 la subconsulta, fins i tot executar-la per veure si trau el que necessitem (en l'exemple veure si trau el nombre de poblacions de cadascuna de les 34 comarques), i quan estiguem segurs que funciona b\u00e9 crear la consulta principal. 3.2 Sintaxi en el WHERE o el HAVING SELECT ... FROM Taula WHERE camp operador ( _Subconsulta_) Podem observar que el que farem ser\u00e0 comparar algun camp de la taula (o una expressi\u00f3 amb alguna funci\u00f3) amb el resultat que ve de la subconsulta. Abans de veure qu\u00e8 podem posar com a operador o com a camp o fins i tot veure uns predicats que podrem utilitzar, posarem un exemple, per clarificar les coses. Intentarem traure les comarques amb una altura superior a la mitjana. Calcular la mitjana de les altures \u00e9s f\u00e0cil, i ser\u00e0 la subconsulta. El que farem ser\u00e0 comparar l'altura de cada poblaci\u00f3 amb aquesta mitjana. SELECT * FROM POBLACIONS WHERE altura > (SELECT AVG(altura) FROM POBLACIONS) Si executeu la consulta, veureu que l'altura de tots els pobles \u00e9s superior a 300,44 que \u00e9s l'altura mitjana (aproximadament, perqu\u00e8 ho calcula amb molta precisi\u00f3) No hi ha cap problema en posar dues vegades la mateixa taula. Els camps es refereixen a la taula m\u00e9s propera. I funciona perfectament perqu\u00e8 la subconsulta ens torna un \u00fanic valor, la mitjana d'altures, i en la consulta principal es compara cada altura amb aquest valor. Posteriorment veurem com solucionar el problema de que la subconsulta torne m\u00e9s d'un valor. Operadors de comparaci\u00f3 i predicats ANY, ALL, SOME \u00c9s com l'exemple de dalt, per\u00f2 amb qualsevol operador de comparaci\u00f3. Es compara el camp (o l'expressi\u00f3) amb el resultat de la subconsulta. Si la subconsulta nom\u00e9s torna un valor, no hi ha m\u00e9s problema, per\u00f2 si torna m\u00e9s d'un valor (m\u00e9s d'una fila) de moment seria incorrecte (no es pot comparar un camp amb uns quants valors). Posem un altre exemple per il\u00b7lustrar. Traure la poblaci\u00f3 m\u00e9s alta es podria fer d'aquesta manera. SELECT * FROM POBLACIONS WHERE altura = (SELECT MAX(altura) FROM POBLACIONS) No hi ha problema perqu\u00e8 la subconsulta torna un valor. Per\u00f2 anem a complicar-la anem a veure les poblacions m\u00e9s altes de cada comarca. Podr\u00edem intentar-lo d'aquesta manera: SELECT * FROM POBLACIONS WHERE altura = (SELECT MAX(altura) FROM POBLACIONS GROUP BY nom_c) Per\u00f2 ens donaria el seg\u00fcent error: I \u00e9s que la subconsulta torna 34 valors (un per cada comarca), i d'aquesta manera no es pot comparar el valor de l'esquerra del igual amb els 34 valors de la dreta. Per a solucionar el problema de quan torna m\u00e9s d'un valor podem utilitzar els predicats ALL , ANY , SOME . Si utilitzem ALL el resultat ser\u00e0 cert si la comparaci\u00f3 \u00e9s certa amb TOTS els valors que torna la subconsulta. Si utilitzem ANY o SOME (que s\u00f3n sin\u00f2nims) el resultat ser\u00e0 cert si la comparaci\u00f3 \u00e9s certa amb ALGUN valor de la subconsulta . En el nostre exemple, segurament ens convindria ANY SELECT * FROM POBLACIONS WHERE altura = ANY (SELECT MAX(altura) FROM POBLACIONS GROUP BY nom_c) Aquesta consulta no funcionar\u00e0 b\u00e9 del tot, ja que seleccionar\u00e0 totes les poblacions que coincideixen amb alguna de les altures m\u00e0ximes, siguen de la seua comarca o no. Aix\u00ed per exemple, l'altura m\u00e0xima de la comarca de la Plana Alta \u00e9s la Serratella, amb 781 metres, que efectivament apareix al llistat. Per\u00f2 tamb\u00e9 apareix Castell\u00f3 , que t\u00e9 una altura de 30 metres. I apareix perqu\u00e8 l'altura m\u00e0xima de la comarca Ribera Baixa d\u00f3na la casualitat que \u00e9s 30 metres (Almussafes). Ja dependrem a fer b\u00e9 aquesta consulta en els exemples posteriors, per\u00f2 per al fet de comparar amb molts valors ens va b\u00e9. L'operador IN No ser\u00e0 problema que la subconsulta torne un valor o molts. La condici\u00f3 ser\u00e0 certa si el valor del camp (o de l'expressi\u00f3) est\u00e0 entre la llista de valors que torna la subconsulta. Tamb\u00e9 poden utilitzar NOT IN, i la condici\u00f3 ser\u00e0 certa quan el valor del camp no est\u00e0 entre la llista. Per exemple, una altra manera de traure les poblacions que no tenen institut, que la vista en les combinacions externes. En la subconsulta traem els codis de municipi de la taula INSTITUTS, i per tant s\u00f3n els pobles que tenen institut, i en la consulta principal volem els que no estan en aquesta llista SELECT * FROM POBLACIONS WHERE cod_m NOT IN (SELECT cod_m FROM INSTITUTS) L'operador EXISTS \u00c9s segurament el m\u00e9s inc\u00f2mode. No es compara un camp (o expressi\u00f3) amb la subconsulta, sin\u00f3 \u00fanicament es posa [NOT] EXISTS ( subconsulta ) . La condici\u00f3 ser\u00e0 certa si la subconsulta torna alguna fila , i no ser\u00e0 certa si no torna cap fila. Intentem fer el mateix exemple d'abans, el dels pobles sense institut. Hem d'aconseguir que la subconsulta no tinga cap fila en el cas dels que no tenen institut. De paraula ho podem dir aix\u00ed: volem els pobles per als quals no existeix cap fila en INSTITUTS amb el mateix codi de municipi. Ara ja es pot intuir per on van els tirs: SELECT * FROM POBLACIONS WHERE NOT EXISTS (SELECT * FROM INSTITUTS WHERE cod_m= POBLACIONS.cod_m) mireu com si en la subconsulta posem un camp (en l'exemple cod_m), si el camp \u00e9s de la taula (o taules) de la subconsulta, es referir\u00e0 a ell, per aix\u00f2 si volem fer refer\u00e8ncia a un camp de la taula o taules de la consulta principal hem de posar el nom de la taula davant. 3.3 Sintaxi en el SELECT SELECT ... ( _Subconsulta_) FROM Taula Anem a posar tamb\u00e9 un exemple per entendre-ho. Anem a calcular la difer\u00e8ncia de l'altura de cada poblaci\u00f3 amb la mitjana. La mitjana \u00e9s un resultat global indepentent de la resta de la consulta, que en aquest cas \u00e9s molt senzilla perqu\u00e8 hem d'agafar informaci\u00f3 simple de les poblacions. La subconsulta tamb\u00e9 \u00e9s molt senzilla, perqu\u00e8 nom\u00e9s hem de calcular la mitjana d'altures). SELECT nom, altura, altura - (SELECT AVG(altura) FROM POBLACIONS) FROM POBLACIONS Exemples 1) Traure l'altura mitjana de comarca m\u00e9s gran i la m\u00e9s menuda. Ens fa falta pr\u00e8viament l'altura mitjana de cada comarca, i aix\u00f2 ser\u00e0 la subconsulta. No oblidem posar un \u00e0lias al camp de la subconsulta, per poder fer refer\u00e8ncia en la consulta principal. I no oblidem tampoc que les subconsultes en el FROM han de tenir \u00e0lies. SELECT MAX(mitjana),MIN(mitjana) FROM (SELECT AVG(altura) AS mitjana FROM POBLACIONS GROUP BY nom_c) AS S; 2) Traure tota la informaci\u00f3 de les poblacions que tenen m\u00e9s de 5 instituts. Podem pensar en una subconsulta on estiguen els codis de municipi de les poblacions que tenen m\u00e9s de 5 instituts (es consulta en la teula INSTITUTS agrupant per codi_m i comptant el n\u00famero de files per a que siga major que 5). SELECT * FROM POBLACIONS WHERE cod_m IN (SELECT cod_m FROM INSTITUTS GROUP BY cod_m HAVING count(*) > 5) 3) Traure tota la informaci\u00f3 de la poblaci\u00f3 m\u00e9s alta i de la m\u00e9s baixa. Ens plantegem 2 subconsultes, la que trau l'altura m\u00e0xima i la que trau l'altura m\u00ednima (en una \u00fanica sobconsulta ens tornaria valors en 2 columnes, i estaria m\u00e9s complicat). Senzillament ser\u00e0 traure tota la informaci\u00f3 de les poblacions que tenen una altura igual al que torna una subconsulta o al que torna l'altra. SELECT * FROM POBLACIONS WHERE altura = (SELECT MAX(altura) FROM POBLACIONS) OR altura = (SELECT MIN(altura) FROM POBLACIONS); 4) Traure la poblaci\u00f3 m\u00e9s alta de cada comarca. La dificultat est\u00e0 en que ha de ser la m\u00e0xima de les altures de la seua comarca. Per tant, en la subconsulta hem de fer refer\u00e8ncia a la comarca en q\u00fcesti\u00f3. Com sempre estem tractant la taula POBLACIONS, tant en la consulta com en la subconsulta, haurem de posar un nom a la de la consulta principal, per poder fer refer\u00e8ncia a ella des de la subconsulta. SELECT * FROM POBLACIONS T1 WHERE altura = (SELECT MAX(altura) FROM POBLACIONS WHERE nom_c= T1.nom_c); En el resultat obtenim 35 poblacions, quan nom\u00e9s hi ha 34 comarques. La ra\u00f3 \u00e9s que a l'Alcoi\u00e0, hi ha 2 poblacions amb l'altura m\u00e0xima (816 metres), per tant el resultat \u00e9s correcte 5) Obtenir el nom de la comarca i la prov\u00edncia de les comarques que tenen una altura mitjana m\u00e9s alta que la mitjana de totes les poblacions. La subconsulta ser\u00e0 prou senzilla: la mitjana d'altures de les poblacions. En la consulta principal haurem d'agrupar per cada comarca i calcular la mitjana d'altures de les poblacions, i comparar-la amb la mitjana que ens ve de la subconsulta. Com que demana tamb\u00e9 la prov\u00edncia, ens fa falta tamb\u00e9 la taula COMARQUES, i per tant l'haurem de reunir amb POBLACIONS; en aquesta ocasi\u00f3 ho hem fet posant la condic\u00f3 en el WHERE. SELECT COMARQUES.nom_c, provincia, AVG(altura) FROM COMARQUES , POBLACIONS WHERE COMARQUES.nom_c=POBLACIONS.nom_c GROUP BY COMARQUES.nom_c, provincia HAVING AVG(altura) > (SELECT AVG(altura) FROM POBLACIONS) 6) Traure el nom de la comarca amb la prov\u00edncia, n\u00famero de pobles de cadascuna i el percentatge que suposa respecta al total de pobles. Tota la informaci\u00f3 la podem traure d'una reuni\u00f3 entre les taules COMARQUES i POBLACIONS (per a comptar quants pobles hi ha en cada comarca), per\u00f2 per a poder calcular el percentatge necessitem el n\u00famero total de poblacions, que el podem calcular amb una senzilla subconsulta. El lloc m\u00e9s c\u00f2mode \u00e9s en el SELECT. La reuni\u00f3 l'hem feta en aquesta ocasi\u00f3 amb el USING. SELECT COMARQUES.nom_c, provincia, COUNT(cod_m), COUNT (cod_m)*100.0/(SELECT COUNT(*) FROM POBLACIONS) FROM COMARQUES INNER JOIN POBLACIONS USING(nom_c) GROUP BY 1,2; Exercicis Ex_64 Traure el n\u00famero m\u00e0xim de factures fetes a un client Ex_65 Traure el l'import que suposa la factura m\u00e9s cara i l'import que suposa la m\u00e9s barata (sense considerar ni descomptes ni IVA) Ex_66 Traure el n\u00famero de factures m\u00e9s alt que s'ha venut per venedor en cada trimestre (no traurem qui \u00e9s el venedor, que seria encara m\u00e9s complicat). Per a poder agrupar per trimestre, ens far\u00e0 falta la funci\u00f3 TO_CHAR (data,'Q') , que trau el n\u00famero de trimestre. El pas previ \u00e9s calcular el n\u00famero de factures de cada venedor i en cada trimestre. Despr\u00e9s, amb la informaci\u00f3 anterior, voldrem calcular el m\u00e0xim de cada trimestre. Ex_67 Traure els articles m\u00e9s cars que la mitjana. Tragueu-los ordenats per la categoria, i despr\u00e9s per codi d'article. Ex_68 Modificar l'anterior per a traure els articles m\u00e9s cars que la mitjana de la seua categoria. Tragueu-los ordenats per la categoria Ex_69 Traure els pobles on tenim clients per\u00f2 no tenim venedors. Ha de ser per mig de subconsultes (en plural). Ordeneu per codi del poble. Ex_70 Traure els pobles on tenim m\u00e9s venedors que clients. Traure el codi del poble, el nom i el n\u00famero de venedors. Ordena per nom del poble. Ex_71 Traure l'import de la factura m\u00e9s cara de cada trimestre. La informaci\u00f3 pr\u00e8via \u00e9s la factura amb la data i l'import. A partir d'ah\u00ed haurem de calcular el m\u00e0xim de l'import per a cada trimestre (no caldr\u00e0 traure quina factura \u00e9s). Ex_72 Traure el nom del venedor, el n\u00famero de factures que ha venut i el percentatge que suposa sobre el total. Podria ser que en el moment de calcular el percentatge, el n\u00famero resultant s'haja de convertir a num\u00e8ric per a que d\u00f3ne b\u00e9 el resultat, ja que en fer una operaci\u00f3 amb enters, el resultat ser\u00e0 enter. Aleshores haur\u00edem d'obligar a que el n\u00famero tinga decimals ( ::NUMERIC ). I la funci\u00f3 d'arrodonir \u00e9s ROUND . Ordeneu pel nom. Ex_73 Traure tota la informaci\u00f3 (amb l'import) de la factura m\u00e9s cara. Ha de ser per mig de subconsultes. Mireu que segurament hi haur\u00e0 2 subconsultes. En la m\u00e9s interna calculem l'import de les factures. En l'altra calculem el m\u00e0xim. I en la consulta principal, busquem la factura que coincideix amb aquest m\u00e0xim. Ex_74 (voluntari) Obtenir el venedor que ha venut m\u00e9s unitats de cada categoria, sense considerar en la categoria el valor nul. Aquesta consulta la podr\u00edem considerar ja com molt avan\u00e7ada. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"3. Subconsultes"},{"location":"BD_PostgreSQL_DQL_Avancat/23_subconsultes/#3-subconsultes","text":"Una subconsulta \u00e9s una consulta dins d'una altra consulta. Aquesta subconsulta pot tenir tots els elements que hem vist fins ara. El lloc on posar una subconsulta dins de la consulta principal pot ser en la cl\u00e0usual WHERE o en la cl\u00e0usula HAVING (formant part d'una condici\u00f3) o en el FROM, i ha d'anar entre par\u00e8ntesis. Fins i tot es pot posar en el mateix SELECT, \u00e9s a dir, en les columnes que van despr\u00e9s del SELECT. Si va en el FROM , la subconsulta ser\u00e0 l'origen de les dades, i per tant s'executar\u00e0 abans i proporcionar\u00e0 les dades per a la consulta principal. Si va en el WHERE o el HAVING formar\u00e0 part d'una condici\u00f3, i aix\u00ed podrem comparar en la consulta principal un camp amb el que torne la subconsulta, per exemple. A banda de les comparacions normals que ja hem vist en el WHERE o el HAVING, podrem posar alguns operadors i predicats especials, com veurem m\u00e9s avant. Si va en el mateix SELECT normalment ser\u00e0 per a traure un resultat global que no afecta a la resta de la consulta","title":"3 Subconsultes"},{"location":"BD_PostgreSQL_DQL_Avancat/23_subconsultes/#31-sintaxi-en-el-from","text":"SELECT ... FROM ( _Subconsulta_) AS _Nom_Subconsulta_ Anem a posar un exemple per entendre-ho. Volem traure la mitjana de pobles per comarca. Ho podem fer de la seg\u00fcent manera: primer comptem quants pobles hi ha en cada comarca, i una vegada calculat aix\u00f2 traem la mitjana. SELECT AVG(quants) FROM (SELECT COUNT(*) AS quants FROM POBLACIONS GROUP BY nom_c) AS S ; Observeu que \u00e9s necessari posar-li un \u00e0lias a la columna de la subconsulta (quants) per a poder fer refer\u00e8ncia a ella en la consulta principal. I per una altra banda, en PostgreSQL les subconsultes que van al FROM han de tenir obligat\u00f2riament un \u00e0lies. Si no pos\u00e0rem ... AS S (o qualsevol altre nom) ens donaria error. Com veieu, ja t\u00e9 un nivell de complexitat m\u00e9s que acceptable. Sempre s'executa primer la subconsulta i amb les dades que proporciona, s'executa la consulta principal. Pel grau de complexitat \u00e9s molt recomanable anar de dins cap a fora, \u00e9s a dir, pensar b\u00e9 la subconsulta, fins i tot executar-la per veure si trau el que necessitem (en l'exemple veure si trau el nombre de poblacions de cadascuna de les 34 comarques), i quan estiguem segurs que funciona b\u00e9 crear la consulta principal.","title":"3.1 Sintaxi en el FROM"},{"location":"BD_PostgreSQL_DQL_Avancat/23_subconsultes/#32-sintaxi-en-el-where-o-el-having","text":"SELECT ... FROM Taula WHERE camp operador ( _Subconsulta_) Podem observar que el que farem ser\u00e0 comparar algun camp de la taula (o una expressi\u00f3 amb alguna funci\u00f3) amb el resultat que ve de la subconsulta. Abans de veure qu\u00e8 podem posar com a operador o com a camp o fins i tot veure uns predicats que podrem utilitzar, posarem un exemple, per clarificar les coses. Intentarem traure les comarques amb una altura superior a la mitjana. Calcular la mitjana de les altures \u00e9s f\u00e0cil, i ser\u00e0 la subconsulta. El que farem ser\u00e0 comparar l'altura de cada poblaci\u00f3 amb aquesta mitjana. SELECT * FROM POBLACIONS WHERE altura > (SELECT AVG(altura) FROM POBLACIONS) Si executeu la consulta, veureu que l'altura de tots els pobles \u00e9s superior a 300,44 que \u00e9s l'altura mitjana (aproximadament, perqu\u00e8 ho calcula amb molta precisi\u00f3) No hi ha cap problema en posar dues vegades la mateixa taula. Els camps es refereixen a la taula m\u00e9s propera. I funciona perfectament perqu\u00e8 la subconsulta ens torna un \u00fanic valor, la mitjana d'altures, i en la consulta principal es compara cada altura amb aquest valor. Posteriorment veurem com solucionar el problema de que la subconsulta torne m\u00e9s d'un valor. Operadors de comparaci\u00f3 i predicats ANY, ALL, SOME \u00c9s com l'exemple de dalt, per\u00f2 amb qualsevol operador de comparaci\u00f3. Es compara el camp (o l'expressi\u00f3) amb el resultat de la subconsulta. Si la subconsulta nom\u00e9s torna un valor, no hi ha m\u00e9s problema, per\u00f2 si torna m\u00e9s d'un valor (m\u00e9s d'una fila) de moment seria incorrecte (no es pot comparar un camp amb uns quants valors). Posem un altre exemple per il\u00b7lustrar. Traure la poblaci\u00f3 m\u00e9s alta es podria fer d'aquesta manera. SELECT * FROM POBLACIONS WHERE altura = (SELECT MAX(altura) FROM POBLACIONS) No hi ha problema perqu\u00e8 la subconsulta torna un valor. Per\u00f2 anem a complicar-la anem a veure les poblacions m\u00e9s altes de cada comarca. Podr\u00edem intentar-lo d'aquesta manera: SELECT * FROM POBLACIONS WHERE altura = (SELECT MAX(altura) FROM POBLACIONS GROUP BY nom_c) Per\u00f2 ens donaria el seg\u00fcent error: I \u00e9s que la subconsulta torna 34 valors (un per cada comarca), i d'aquesta manera no es pot comparar el valor de l'esquerra del igual amb els 34 valors de la dreta. Per a solucionar el problema de quan torna m\u00e9s d'un valor podem utilitzar els predicats ALL , ANY , SOME . Si utilitzem ALL el resultat ser\u00e0 cert si la comparaci\u00f3 \u00e9s certa amb TOTS els valors que torna la subconsulta. Si utilitzem ANY o SOME (que s\u00f3n sin\u00f2nims) el resultat ser\u00e0 cert si la comparaci\u00f3 \u00e9s certa amb ALGUN valor de la subconsulta . En el nostre exemple, segurament ens convindria ANY SELECT * FROM POBLACIONS WHERE altura = ANY (SELECT MAX(altura) FROM POBLACIONS GROUP BY nom_c) Aquesta consulta no funcionar\u00e0 b\u00e9 del tot, ja que seleccionar\u00e0 totes les poblacions que coincideixen amb alguna de les altures m\u00e0ximes, siguen de la seua comarca o no. Aix\u00ed per exemple, l'altura m\u00e0xima de la comarca de la Plana Alta \u00e9s la Serratella, amb 781 metres, que efectivament apareix al llistat. Per\u00f2 tamb\u00e9 apareix Castell\u00f3 , que t\u00e9 una altura de 30 metres. I apareix perqu\u00e8 l'altura m\u00e0xima de la comarca Ribera Baixa d\u00f3na la casualitat que \u00e9s 30 metres (Almussafes). Ja dependrem a fer b\u00e9 aquesta consulta en els exemples posteriors, per\u00f2 per al fet de comparar amb molts valors ens va b\u00e9. L'operador IN No ser\u00e0 problema que la subconsulta torne un valor o molts. La condici\u00f3 ser\u00e0 certa si el valor del camp (o de l'expressi\u00f3) est\u00e0 entre la llista de valors que torna la subconsulta. Tamb\u00e9 poden utilitzar NOT IN, i la condici\u00f3 ser\u00e0 certa quan el valor del camp no est\u00e0 entre la llista. Per exemple, una altra manera de traure les poblacions que no tenen institut, que la vista en les combinacions externes. En la subconsulta traem els codis de municipi de la taula INSTITUTS, i per tant s\u00f3n els pobles que tenen institut, i en la consulta principal volem els que no estan en aquesta llista SELECT * FROM POBLACIONS WHERE cod_m NOT IN (SELECT cod_m FROM INSTITUTS) L'operador EXISTS \u00c9s segurament el m\u00e9s inc\u00f2mode. No es compara un camp (o expressi\u00f3) amb la subconsulta, sin\u00f3 \u00fanicament es posa [NOT] EXISTS ( subconsulta ) . La condici\u00f3 ser\u00e0 certa si la subconsulta torna alguna fila , i no ser\u00e0 certa si no torna cap fila. Intentem fer el mateix exemple d'abans, el dels pobles sense institut. Hem d'aconseguir que la subconsulta no tinga cap fila en el cas dels que no tenen institut. De paraula ho podem dir aix\u00ed: volem els pobles per als quals no existeix cap fila en INSTITUTS amb el mateix codi de municipi. Ara ja es pot intuir per on van els tirs: SELECT * FROM POBLACIONS WHERE NOT EXISTS (SELECT * FROM INSTITUTS WHERE cod_m= POBLACIONS.cod_m) mireu com si en la subconsulta posem un camp (en l'exemple cod_m), si el camp \u00e9s de la taula (o taules) de la subconsulta, es referir\u00e0 a ell, per aix\u00f2 si volem fer refer\u00e8ncia a un camp de la taula o taules de la consulta principal hem de posar el nom de la taula davant.","title":"3.2 Sintaxi en el WHERE o el HAVING"},{"location":"BD_PostgreSQL_DQL_Avancat/23_subconsultes/#33-sintaxi-en-el-select","text":"SELECT ... ( _Subconsulta_) FROM Taula Anem a posar tamb\u00e9 un exemple per entendre-ho. Anem a calcular la difer\u00e8ncia de l'altura de cada poblaci\u00f3 amb la mitjana. La mitjana \u00e9s un resultat global indepentent de la resta de la consulta, que en aquest cas \u00e9s molt senzilla perqu\u00e8 hem d'agafar informaci\u00f3 simple de les poblacions. La subconsulta tamb\u00e9 \u00e9s molt senzilla, perqu\u00e8 nom\u00e9s hem de calcular la mitjana d'altures). SELECT nom, altura, altura - (SELECT AVG(altura) FROM POBLACIONS) FROM POBLACIONS Exemples 1) Traure l'altura mitjana de comarca m\u00e9s gran i la m\u00e9s menuda. Ens fa falta pr\u00e8viament l'altura mitjana de cada comarca, i aix\u00f2 ser\u00e0 la subconsulta. No oblidem posar un \u00e0lias al camp de la subconsulta, per poder fer refer\u00e8ncia en la consulta principal. I no oblidem tampoc que les subconsultes en el FROM han de tenir \u00e0lies. SELECT MAX(mitjana),MIN(mitjana) FROM (SELECT AVG(altura) AS mitjana FROM POBLACIONS GROUP BY nom_c) AS S; 2) Traure tota la informaci\u00f3 de les poblacions que tenen m\u00e9s de 5 instituts. Podem pensar en una subconsulta on estiguen els codis de municipi de les poblacions que tenen m\u00e9s de 5 instituts (es consulta en la teula INSTITUTS agrupant per codi_m i comptant el n\u00famero de files per a que siga major que 5). SELECT * FROM POBLACIONS WHERE cod_m IN (SELECT cod_m FROM INSTITUTS GROUP BY cod_m HAVING count(*) > 5) 3) Traure tota la informaci\u00f3 de la poblaci\u00f3 m\u00e9s alta i de la m\u00e9s baixa. Ens plantegem 2 subconsultes, la que trau l'altura m\u00e0xima i la que trau l'altura m\u00ednima (en una \u00fanica sobconsulta ens tornaria valors en 2 columnes, i estaria m\u00e9s complicat). Senzillament ser\u00e0 traure tota la informaci\u00f3 de les poblacions que tenen una altura igual al que torna una subconsulta o al que torna l'altra. SELECT * FROM POBLACIONS WHERE altura = (SELECT MAX(altura) FROM POBLACIONS) OR altura = (SELECT MIN(altura) FROM POBLACIONS); 4) Traure la poblaci\u00f3 m\u00e9s alta de cada comarca. La dificultat est\u00e0 en que ha de ser la m\u00e0xima de les altures de la seua comarca. Per tant, en la subconsulta hem de fer refer\u00e8ncia a la comarca en q\u00fcesti\u00f3. Com sempre estem tractant la taula POBLACIONS, tant en la consulta com en la subconsulta, haurem de posar un nom a la de la consulta principal, per poder fer refer\u00e8ncia a ella des de la subconsulta. SELECT * FROM POBLACIONS T1 WHERE altura = (SELECT MAX(altura) FROM POBLACIONS WHERE nom_c= T1.nom_c); En el resultat obtenim 35 poblacions, quan nom\u00e9s hi ha 34 comarques. La ra\u00f3 \u00e9s que a l'Alcoi\u00e0, hi ha 2 poblacions amb l'altura m\u00e0xima (816 metres), per tant el resultat \u00e9s correcte 5) Obtenir el nom de la comarca i la prov\u00edncia de les comarques que tenen una altura mitjana m\u00e9s alta que la mitjana de totes les poblacions. La subconsulta ser\u00e0 prou senzilla: la mitjana d'altures de les poblacions. En la consulta principal haurem d'agrupar per cada comarca i calcular la mitjana d'altures de les poblacions, i comparar-la amb la mitjana que ens ve de la subconsulta. Com que demana tamb\u00e9 la prov\u00edncia, ens fa falta tamb\u00e9 la taula COMARQUES, i per tant l'haurem de reunir amb POBLACIONS; en aquesta ocasi\u00f3 ho hem fet posant la condic\u00f3 en el WHERE. SELECT COMARQUES.nom_c, provincia, AVG(altura) FROM COMARQUES , POBLACIONS WHERE COMARQUES.nom_c=POBLACIONS.nom_c GROUP BY COMARQUES.nom_c, provincia HAVING AVG(altura) > (SELECT AVG(altura) FROM POBLACIONS) 6) Traure el nom de la comarca amb la prov\u00edncia, n\u00famero de pobles de cadascuna i el percentatge que suposa respecta al total de pobles. Tota la informaci\u00f3 la podem traure d'una reuni\u00f3 entre les taules COMARQUES i POBLACIONS (per a comptar quants pobles hi ha en cada comarca), per\u00f2 per a poder calcular el percentatge necessitem el n\u00famero total de poblacions, que el podem calcular amb una senzilla subconsulta. El lloc m\u00e9s c\u00f2mode \u00e9s en el SELECT. La reuni\u00f3 l'hem feta en aquesta ocasi\u00f3 amb el USING. SELECT COMARQUES.nom_c, provincia, COUNT(cod_m), COUNT (cod_m)*100.0/(SELECT COUNT(*) FROM POBLACIONS) FROM COMARQUES INNER JOIN POBLACIONS USING(nom_c) GROUP BY 1,2;","title":"3.3 Sintaxi en el SELECT"},{"location":"BD_PostgreSQL_DQL_Avancat/23_subconsultes/#exercicis","text":"Ex_64 Traure el n\u00famero m\u00e0xim de factures fetes a un client Ex_65 Traure el l'import que suposa la factura m\u00e9s cara i l'import que suposa la m\u00e9s barata (sense considerar ni descomptes ni IVA) Ex_66 Traure el n\u00famero de factures m\u00e9s alt que s'ha venut per venedor en cada trimestre (no traurem qui \u00e9s el venedor, que seria encara m\u00e9s complicat). Per a poder agrupar per trimestre, ens far\u00e0 falta la funci\u00f3 TO_CHAR (data,'Q') , que trau el n\u00famero de trimestre. El pas previ \u00e9s calcular el n\u00famero de factures de cada venedor i en cada trimestre. Despr\u00e9s, amb la informaci\u00f3 anterior, voldrem calcular el m\u00e0xim de cada trimestre. Ex_67 Traure els articles m\u00e9s cars que la mitjana. Tragueu-los ordenats per la categoria, i despr\u00e9s per codi d'article. Ex_68 Modificar l'anterior per a traure els articles m\u00e9s cars que la mitjana de la seua categoria. Tragueu-los ordenats per la categoria Ex_69 Traure els pobles on tenim clients per\u00f2 no tenim venedors. Ha de ser per mig de subconsultes (en plural). Ordeneu per codi del poble. Ex_70 Traure els pobles on tenim m\u00e9s venedors que clients. Traure el codi del poble, el nom i el n\u00famero de venedors. Ordena per nom del poble. Ex_71 Traure l'import de la factura m\u00e9s cara de cada trimestre. La informaci\u00f3 pr\u00e8via \u00e9s la factura amb la data i l'import. A partir d'ah\u00ed haurem de calcular el m\u00e0xim de l'import per a cada trimestre (no caldr\u00e0 traure quina factura \u00e9s). Ex_72 Traure el nom del venedor, el n\u00famero de factures que ha venut i el percentatge que suposa sobre el total. Podria ser que en el moment de calcular el percentatge, el n\u00famero resultant s'haja de convertir a num\u00e8ric per a que d\u00f3ne b\u00e9 el resultat, ja que en fer una operaci\u00f3 amb enters, el resultat ser\u00e0 enter. Aleshores haur\u00edem d'obligar a que el n\u00famero tinga decimals ( ::NUMERIC ). I la funci\u00f3 d'arrodonir \u00e9s ROUND . Ordeneu pel nom. Ex_73 Traure tota la informaci\u00f3 (amb l'import) de la factura m\u00e9s cara. Ha de ser per mig de subconsultes. Mireu que segurament hi haur\u00e0 2 subconsultes. En la m\u00e9s interna calculem l'import de les factures. En l'altra calculem el m\u00e0xim. I en la consulta principal, busquem la factura que coincideix amb aquest m\u00e0xim. Ex_74 (voluntari) Obtenir el venedor que ha venut m\u00e9s unitats de cada categoria, sense considerar en la categoria el valor nul. Aquesta consulta la podr\u00edem considerar ja com molt avan\u00e7ada. Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL_Avancat/24_consultes_doperacions_de_conjunts/","text":"4 Consultes d'operacions de conjunts Agruparem en aquest apartat les consultes que tracten conjunts de files per a fer operacions d'algebra de conjunts: uni\u00f3 , intersecci\u00f3 i difer\u00e8ncia de conjunts Toters aquestes consultes ajunten els resultats de dues o m\u00e9s consultes. 4.1 Uni\u00f3 Sintaxi [TABLE] consulta1 UNION [ALL] [TABLE] consulta2 ... Cadascuna de les consultes pot ser una taula (posant la paraula TABLE davant) o el nom d'una consulta ja guardada, encara que el m\u00e9s habitual ser\u00e0 posar directament la sent\u00e8ncia SQL . Els requisits s\u00f3n que les dues (o m\u00e9s) consultes tornen el mateix nombre de camps, i que siguen sin\u00f3 del mateix tipus, s\u00ed de tipus compatibles Igual que en la uni\u00f3 de conjunts, el resultat seran totes les files de les dues (o m\u00e9s) consultes individuals, per\u00f2 sense repetir files, \u00e9s a dir, si de les dues consultes s'obtenen files iguals, aquestes nom\u00e9s eixiran una vegada. L'anterior es pot evitar si posem el predicat ALL, i aleshores s\u00ed que eixiran les files repetides. Els noms dels camps vindran donats per la primera consulta. Si volem ordenar per algun camp, ho haurem de posar al final de l'\u00faltima consulta, per\u00f2 referint-se en tot cas als camps de la primera consulta (ho podem evitar posant el n\u00famero d'ordre en el ORDER BY) Exemple 1) Volem veure en un \u00fanic resultat tant el nom de les comarques com el nom de les poblacions, sempre amb el nom de la prov\u00edncia al costat SELECT nom_c, provincia FROM COMARQUES UNION SELECT nom, provincia FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) ORDER BY nom_c; Com a curiositat, eixiran 575 files, per\u00f2 si pos\u00e0rem UNION ALL ens eixirien 576. Aix\u00f2 \u00e9s perqu\u00e8 la comarca de la ciutat de Val\u00e8ncia es diu Val\u00e8ncia i est\u00e0 a la prov\u00edncia de Val\u00e8ncia. Per tant \u00e9s una fila que apareixer\u00e0 tant en la primera com en la segona consulta. Si fem UNION no es repetir\u00e0, per\u00f2 si fem UNION ALL s\u00ed que es repetir\u00e0. 4.2 Intersecci\u00f3 \u00c9s identica a la uni\u00f3, per\u00f2 posant la paraula INTERSECT , i servir\u00e0 per a traure \u00fanicament les files que estan en les dues consultes. Sintaxi [TABLE] consulta1 INTERSECT [ALL] [TABLE] consulta2 ... Igual que abans, cadascuna de les consultes pot ser una taula (posant la paraula TABLE davant), i tenim el requisit que les dues (o m\u00e9s) consultes tornen el mateix nombre de camps, i de tipus compatibles. En principi no eixiran files repetides, a no ser que posem ALL Exemple 1) Com que en l'exemple de la uni\u00f3 hav\u00edem vist que la fila Val\u00e8ncia Val\u00e8ncia eixia en les 2 consultes, anem a comprovar que apareix en la intersecci\u00f3: SELECT nom_c, provincia FROM COMARQUES INTERSECT SELECT nom, provincia FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) ORDER BY nom_c; 4.3 Difer\u00e8ncia \u00c9s identica a les anteriors, per\u00f2 posant la paraula EXCEPT , i servir\u00e0 per a traure les files que estan en la primera consulta per\u00f2 que no estan en la segona. Sintaxi [TABLE] consulta1 EXCEPT [ALL] [TABLE] consulta2 ... Igual que abans, cadascuna de les consultes pot ser una taula (posant la paraula TABLE davant), i tenim el requisit que les dues (o m\u00e9s) consultes tornen el mateix nombre de camps, i de tipus compatibles. En principi no eixiran files repetides, a no ser que posem ALL Exemple 1) Aprofitem el mateix exemple d'abans per a comprovar que amb EXCEPT no eixir\u00e0 la comarca Val\u00e8ncia, ja que hi ha una fila id\u00e8ntica en la segona consulta: SELECT nom_c, provincia FROM COMARQUES EXCEPT SELECT nom, provincia FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) ORDER BY nom_c; Exercicis Ex_75 Traure el nom de tots els clients i venedors implicats en alguna venda del primer trimestre de 2015. Ex_76a Traure per mig de sent\u00e8ncies d'operacions de conjunts els pobles on tenim algun venedor o algun client. No volem resultats repetits, i ho volem ordenat pel nom del poble. Ex_76b Modificar l'anterior per a traure els pobles on tenim al mateix temps venedors i clients Ex_76c Modificar l'anterior per a traure els pobles on tenim venedors per\u00f2 no tenim clients Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"4. Consultes d'operacions de conjunts"},{"location":"BD_PostgreSQL_DQL_Avancat/24_consultes_doperacions_de_conjunts/#4-consultes-doperacions-de-conjunts","text":"Agruparem en aquest apartat les consultes que tracten conjunts de files per a fer operacions d'algebra de conjunts: uni\u00f3 , intersecci\u00f3 i difer\u00e8ncia de conjunts Toters aquestes consultes ajunten els resultats de dues o m\u00e9s consultes.","title":"4 Consultes d'operacions de conjunts"},{"location":"BD_PostgreSQL_DQL_Avancat/24_consultes_doperacions_de_conjunts/#41-unio","text":"Sintaxi [TABLE] consulta1 UNION [ALL] [TABLE] consulta2 ... Cadascuna de les consultes pot ser una taula (posant la paraula TABLE davant) o el nom d'una consulta ja guardada, encara que el m\u00e9s habitual ser\u00e0 posar directament la sent\u00e8ncia SQL . Els requisits s\u00f3n que les dues (o m\u00e9s) consultes tornen el mateix nombre de camps, i que siguen sin\u00f3 del mateix tipus, s\u00ed de tipus compatibles Igual que en la uni\u00f3 de conjunts, el resultat seran totes les files de les dues (o m\u00e9s) consultes individuals, per\u00f2 sense repetir files, \u00e9s a dir, si de les dues consultes s'obtenen files iguals, aquestes nom\u00e9s eixiran una vegada. L'anterior es pot evitar si posem el predicat ALL, i aleshores s\u00ed que eixiran les files repetides. Els noms dels camps vindran donats per la primera consulta. Si volem ordenar per algun camp, ho haurem de posar al final de l'\u00faltima consulta, per\u00f2 referint-se en tot cas als camps de la primera consulta (ho podem evitar posant el n\u00famero d'ordre en el ORDER BY) Exemple 1) Volem veure en un \u00fanic resultat tant el nom de les comarques com el nom de les poblacions, sempre amb el nom de la prov\u00edncia al costat SELECT nom_c, provincia FROM COMARQUES UNION SELECT nom, provincia FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) ORDER BY nom_c; Com a curiositat, eixiran 575 files, per\u00f2 si pos\u00e0rem UNION ALL ens eixirien 576. Aix\u00f2 \u00e9s perqu\u00e8 la comarca de la ciutat de Val\u00e8ncia es diu Val\u00e8ncia i est\u00e0 a la prov\u00edncia de Val\u00e8ncia. Per tant \u00e9s una fila que apareixer\u00e0 tant en la primera com en la segona consulta. Si fem UNION no es repetir\u00e0, per\u00f2 si fem UNION ALL s\u00ed que es repetir\u00e0.","title":"4.1 Uni\u00f3"},{"location":"BD_PostgreSQL_DQL_Avancat/24_consultes_doperacions_de_conjunts/#42-interseccio","text":"\u00c9s identica a la uni\u00f3, per\u00f2 posant la paraula INTERSECT , i servir\u00e0 per a traure \u00fanicament les files que estan en les dues consultes. Sintaxi [TABLE] consulta1 INTERSECT [ALL] [TABLE] consulta2 ... Igual que abans, cadascuna de les consultes pot ser una taula (posant la paraula TABLE davant), i tenim el requisit que les dues (o m\u00e9s) consultes tornen el mateix nombre de camps, i de tipus compatibles. En principi no eixiran files repetides, a no ser que posem ALL Exemple 1) Com que en l'exemple de la uni\u00f3 hav\u00edem vist que la fila Val\u00e8ncia Val\u00e8ncia eixia en les 2 consultes, anem a comprovar que apareix en la intersecci\u00f3: SELECT nom_c, provincia FROM COMARQUES INTERSECT SELECT nom, provincia FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) ORDER BY nom_c;","title":"4.2 Intersecci\u00f3"},{"location":"BD_PostgreSQL_DQL_Avancat/24_consultes_doperacions_de_conjunts/#43-diferencia","text":"\u00c9s identica a les anteriors, per\u00f2 posant la paraula EXCEPT , i servir\u00e0 per a traure les files que estan en la primera consulta per\u00f2 que no estan en la segona. Sintaxi [TABLE] consulta1 EXCEPT [ALL] [TABLE] consulta2 ... Igual que abans, cadascuna de les consultes pot ser una taula (posant la paraula TABLE davant), i tenim el requisit que les dues (o m\u00e9s) consultes tornen el mateix nombre de camps, i de tipus compatibles. En principi no eixiran files repetides, a no ser que posem ALL Exemple 1) Aprofitem el mateix exemple d'abans per a comprovar que amb EXCEPT no eixir\u00e0 la comarca Val\u00e8ncia, ja que hi ha una fila id\u00e8ntica en la segona consulta: SELECT nom_c, provincia FROM COMARQUES EXCEPT SELECT nom, provincia FROM COMARQUES INNER JOIN POBLACIONS USING (nom_c) ORDER BY nom_c;","title":"4.3 Difer\u00e8ncia"},{"location":"BD_PostgreSQL_DQL_Avancat/24_consultes_doperacions_de_conjunts/#exercicis","text":"Ex_75 Traure el nom de tots els clients i venedors implicats en alguna venda del primer trimestre de 2015. Ex_76a Traure per mig de sent\u00e8ncies d'operacions de conjunts els pobles on tenim algun venedor o algun client. No volem resultats repetits, i ho volem ordenat pel nom del poble. Ex_76b Modificar l'anterior per a traure els pobles on tenim al mateix temps venedors i clients Ex_76c Modificar l'anterior per a traure els pobles on tenim venedors per\u00f2 no tenim clients Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"Exercicis"},{"location":"BD_PostgreSQL_DQL_Avancat/exercicis_de_tot_el_tema_amb_els_resultats/","text":"Exercicis amb els resultats (part II) Ex_51 Traure el nom dels clients amb el n\u00famero de factura i la data (individuals, sense agrupar res) que t\u00e9 cada client. Trau el resultat ordenat per client, i dins d'aquest per data de la factura Un total de 105 files Ex_52 Traure el nom del soci, amb el codi i la descripci\u00f3 de cada article que ha demanat. Ordena per nom del soci i codi de l'article. Un total de 541 files Ex_53 Modificar l'anterior per a que no es repetesquen els resultats. Un total de * 532 files * Observa com ara no es repeteix la fila 10 i 11, i abans s\u00ed Ex_54 Traure el nom dels clients amb la quantitat de factures que tenen, ordenades per aquest n\u00famero de major a menor Un total de 40 files Ex_55 Traure el n\u00famero de factura, data, codi de client, total de la factura (amb l'\u00e0lies IMPORT) i total de la factura aplicant descomptes d'article (amb \u00e0lies DESCOMPTE_1), com en la consulta Ex_33 , per\u00f2 sense el l\u00edmit de les 10 l\u00ednies de factura. Ordena per n\u00famero de factura. Un total de 105 files Ex_56 Modificar l'anterior per a aplicar tamb\u00e9 el descompte de la factura (amb l'\u00e0lies DESCOMPTE_2) Un total de 105 files Ex_57 Traure el codi i nom d'aquells venedors que supervisen alg\u00fa (consten com a cap). Traure tamb\u00e9 el n\u00famero de supervisats de cadascun d'aquestos supervisors. Ex_58 Traure el codi i descripci\u00f3 dels articles juntament amb el n\u00famero de vegades que s'ha venut, el total d'unitats venudes i la mitjana d'unitats venudes per factura. Ordenar pel n\u00famero total d'unitats venudes de forma descendent, i dins d'aquesta per codi d'article de forma ascendent. Un total de 399 files Ex_59 Traure el codi i la descripci\u00f3 de les categories, amb la quantitat d'articles venuts de cada categoria, d'aquelles categories de les quals se n'han venut m\u00e9s de 100 unitats. Ordenar per aquest n\u00famero de forma descendent. Ex_60 Traure el codi i el nom dels clients que no tenen cap factura. Ex_61 Traure el codi, descripci\u00f3 i total d'unitats venudes de tots els articles, fins i tot d'aquells que no s'ha venut res. Nota Per a deixar-lo m\u00e9s bonic, com que la suma de valors nuls no \u00e9s 0 sin\u00f3 nul, per a que ens aparegue el valor 0 podem utilitzar la funci\u00f3 COALESCE( valor ,0), que si el valor \u00e9s nul torna un 0. Un total de 812 files Ex_62 Traure el nom de tots els pobles i el n\u00famero de clients en cas que en tinguen. Ordena per n\u00famero de clients de forma descendent. Un total de 1663 files Ex_63 Traure el codi i la descripci\u00f3 de les categories, amb el n\u00famero d'articles de cada categoria i el n\u00famero total d'unitats venudes de cada categoria, d'aquelles categories de les quals tenim m\u00e9s de 15 articles, i ordenat per n\u00famero d'articles de forma descendent. Aquesta sent\u00e8ncia ja \u00e9s prou complicada. Concretament haureu de tenir en compte que: Voldrem traure el n\u00famero d'articles de cada categoria, per\u00f2 potser alguns articles no s'han venut, i per tant no apareixeran en la taula LINIA_FAC. I tamb\u00e9 tenim el problema que, com ens fa falta la taula LINIA_FAC, un article venut en m\u00e9s d'una factura apareixer\u00e0 m\u00e9s d'una vegada. Si comptem de forma normal, el comptar\u00edem m\u00e9s d'una vegada cada article. Per tant voldrem comptar els diferents articles de cada categoria. Ex_64 Traure el n\u00famero m\u00e0xim de factures fetes a un client Ex_65 Traure el l'import que suposa la factura m\u00e9s cara i l'import que suposa la m\u00e9s barata (sense considerar ni descomptes ni IVA) Ex_66 Traure el n\u00famero de factures m\u00e9s alt que s'ha venut per venedor en cada trimestre (no traurem qui \u00e9s el venedor, que seria encara m\u00e9s complicat). Per a poder agrupar per trimestre, ens far\u00e0 falta la funci\u00f3 TO_CHAR (data,'Q') , que trau el n\u00famero de trimestre. El pas previ \u00e9s calcular el n\u00famero de factures de cada venedor i en cada trimestre. Despr\u00e9s, amb la informaci\u00f3 anterior, voldrem calcular el m\u00e0xim de cada trimestre. Ex_67 Traure els articles m\u00e9s cars que la mitjana. Tragueu-los ordenats per la categoria, i despr\u00e9s per codi d'article. Un total de 164 files Ex_68 Modificar l'anterior per a traure els articles m\u00e9s cars que la mitjana de la seua categoria. Tragueu-los ordenats per la categoria Un total de 75 files \u00c9s un resultat molt similar a l'anterior, per\u00f2 observeu que ara no estan els productes de les files 5, 14, 15, ... Ex_69 Traure els pobles on tenim clients per\u00f2 no tenim venedors. Ha de ser per mig de subconsultes (en plural). Ordeneu per codi del poble. Ex_70 Traure els pobles on tenim m\u00e9s venedors que clients. Traure el codi del poble, el nom i el n\u00famero de venedors. Ordena per nom del poble. Ex_71 Traure l'import de la factura m\u00e9s cara de cada trimestre. La informaci\u00f3 pr\u00e8via \u00e9s la factura amb la data i l'import. A partir d'ah\u00ed haurem de calcular el m\u00e0xim de l'import per a cada trimestre (no caldr\u00e0 traure quina factura \u00e9s). Ex_72 Traure el nom del venedor, el n\u00famero de factures que ha venut i el percentatge que suposa sobre el total. Podria ser que en el moment de calcular el percentatge, el n\u00famero resultant s'haja de convertir a num\u00e8ric per a que d\u00f3ne b\u00e9 el resultat, ja que en fer una operaci\u00f3 amb enters, el resultat ser\u00e0 enter. Aleshores haur\u00edem d'obligar a que el n\u00famero tinga decimals ( ::NUMERIC ). I la funci\u00f3 d'arrodonir \u00e9s ROUND . Ordeneu pel nom. Ex_73 Traure tota la informaci\u00f3 (amb l'import) de la factura m\u00e9s cara. Ha de ser per mig de subconsultes. Mireu que segurament hi haur\u00e0 2 subconsultes. En la m\u00e9s interna calculem l'import de les factures. En l'altra calculem el m\u00e0xim. I en la consulta principal, busquem la factura que coincideix amb aquest m\u00e0xim. Ex_74 (voluntari) Obtenir el venedor que ha venut m\u00e9s unitats de cada categoria, sense considerar en la categoria el valor nul. Aquesta consulta la podr\u00edem considerar ja com molt avan\u00e7ada. Ex_75 Traure el nom de tots els clients i venedors implicats en alguna venda del primer trimestre de 2015. Intentar traure en una segona columna el text Venedor per als venedors, i Client per als clients. Ordenat pel nom. Ex_76a Traure per mig de sent\u00e8ncies d'operacions de conjunts els pobles on tenim algun venedor o algun client. No volem resultats repetits, i ho volem ordenat pel nom del poble. Un total de 31 files Ex_76b Modificar l'anterior per a traure els pobles on tenim al mateix temps venedors i clients Ex_76c Modificar l'anterior per a traure els pobles on tenim venedors per\u00f2 no tenim clients Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"Exercicis amb els resultats (part II)"},{"location":"BD_PostgreSQL_DQL_Avancat/exercicis_de_tot_el_tema_amb_els_resultats/#exercicis-amb-els-resultats-part-ii","text":"Ex_51 Traure el nom dels clients amb el n\u00famero de factura i la data (individuals, sense agrupar res) que t\u00e9 cada client. Trau el resultat ordenat per client, i dins d'aquest per data de la factura Un total de 105 files Ex_52 Traure el nom del soci, amb el codi i la descripci\u00f3 de cada article que ha demanat. Ordena per nom del soci i codi de l'article. Un total de 541 files Ex_53 Modificar l'anterior per a que no es repetesquen els resultats. Un total de * 532 files * Observa com ara no es repeteix la fila 10 i 11, i abans s\u00ed Ex_54 Traure el nom dels clients amb la quantitat de factures que tenen, ordenades per aquest n\u00famero de major a menor Un total de 40 files Ex_55 Traure el n\u00famero de factura, data, codi de client, total de la factura (amb l'\u00e0lies IMPORT) i total de la factura aplicant descomptes d'article (amb \u00e0lies DESCOMPTE_1), com en la consulta Ex_33 , per\u00f2 sense el l\u00edmit de les 10 l\u00ednies de factura. Ordena per n\u00famero de factura. Un total de 105 files Ex_56 Modificar l'anterior per a aplicar tamb\u00e9 el descompte de la factura (amb l'\u00e0lies DESCOMPTE_2) Un total de 105 files Ex_57 Traure el codi i nom d'aquells venedors que supervisen alg\u00fa (consten com a cap). Traure tamb\u00e9 el n\u00famero de supervisats de cadascun d'aquestos supervisors. Ex_58 Traure el codi i descripci\u00f3 dels articles juntament amb el n\u00famero de vegades que s'ha venut, el total d'unitats venudes i la mitjana d'unitats venudes per factura. Ordenar pel n\u00famero total d'unitats venudes de forma descendent, i dins d'aquesta per codi d'article de forma ascendent. Un total de 399 files Ex_59 Traure el codi i la descripci\u00f3 de les categories, amb la quantitat d'articles venuts de cada categoria, d'aquelles categories de les quals se n'han venut m\u00e9s de 100 unitats. Ordenar per aquest n\u00famero de forma descendent. Ex_60 Traure el codi i el nom dels clients que no tenen cap factura. Ex_61 Traure el codi, descripci\u00f3 i total d'unitats venudes de tots els articles, fins i tot d'aquells que no s'ha venut res. Nota Per a deixar-lo m\u00e9s bonic, com que la suma de valors nuls no \u00e9s 0 sin\u00f3 nul, per a que ens aparegue el valor 0 podem utilitzar la funci\u00f3 COALESCE( valor ,0), que si el valor \u00e9s nul torna un 0. Un total de 812 files Ex_62 Traure el nom de tots els pobles i el n\u00famero de clients en cas que en tinguen. Ordena per n\u00famero de clients de forma descendent. Un total de 1663 files Ex_63 Traure el codi i la descripci\u00f3 de les categories, amb el n\u00famero d'articles de cada categoria i el n\u00famero total d'unitats venudes de cada categoria, d'aquelles categories de les quals tenim m\u00e9s de 15 articles, i ordenat per n\u00famero d'articles de forma descendent. Aquesta sent\u00e8ncia ja \u00e9s prou complicada. Concretament haureu de tenir en compte que: Voldrem traure el n\u00famero d'articles de cada categoria, per\u00f2 potser alguns articles no s'han venut, i per tant no apareixeran en la taula LINIA_FAC. I tamb\u00e9 tenim el problema que, com ens fa falta la taula LINIA_FAC, un article venut en m\u00e9s d'una factura apareixer\u00e0 m\u00e9s d'una vegada. Si comptem de forma normal, el comptar\u00edem m\u00e9s d'una vegada cada article. Per tant voldrem comptar els diferents articles de cada categoria. Ex_64 Traure el n\u00famero m\u00e0xim de factures fetes a un client Ex_65 Traure el l'import que suposa la factura m\u00e9s cara i l'import que suposa la m\u00e9s barata (sense considerar ni descomptes ni IVA) Ex_66 Traure el n\u00famero de factures m\u00e9s alt que s'ha venut per venedor en cada trimestre (no traurem qui \u00e9s el venedor, que seria encara m\u00e9s complicat). Per a poder agrupar per trimestre, ens far\u00e0 falta la funci\u00f3 TO_CHAR (data,'Q') , que trau el n\u00famero de trimestre. El pas previ \u00e9s calcular el n\u00famero de factures de cada venedor i en cada trimestre. Despr\u00e9s, amb la informaci\u00f3 anterior, voldrem calcular el m\u00e0xim de cada trimestre. Ex_67 Traure els articles m\u00e9s cars que la mitjana. Tragueu-los ordenats per la categoria, i despr\u00e9s per codi d'article. Un total de 164 files Ex_68 Modificar l'anterior per a traure els articles m\u00e9s cars que la mitjana de la seua categoria. Tragueu-los ordenats per la categoria Un total de 75 files \u00c9s un resultat molt similar a l'anterior, per\u00f2 observeu que ara no estan els productes de les files 5, 14, 15, ... Ex_69 Traure els pobles on tenim clients per\u00f2 no tenim venedors. Ha de ser per mig de subconsultes (en plural). Ordeneu per codi del poble. Ex_70 Traure els pobles on tenim m\u00e9s venedors que clients. Traure el codi del poble, el nom i el n\u00famero de venedors. Ordena per nom del poble. Ex_71 Traure l'import de la factura m\u00e9s cara de cada trimestre. La informaci\u00f3 pr\u00e8via \u00e9s la factura amb la data i l'import. A partir d'ah\u00ed haurem de calcular el m\u00e0xim de l'import per a cada trimestre (no caldr\u00e0 traure quina factura \u00e9s). Ex_72 Traure el nom del venedor, el n\u00famero de factures que ha venut i el percentatge que suposa sobre el total. Podria ser que en el moment de calcular el percentatge, el n\u00famero resultant s'haja de convertir a num\u00e8ric per a que d\u00f3ne b\u00e9 el resultat, ja que en fer una operaci\u00f3 amb enters, el resultat ser\u00e0 enter. Aleshores haur\u00edem d'obligar a que el n\u00famero tinga decimals ( ::NUMERIC ). I la funci\u00f3 d'arrodonir \u00e9s ROUND . Ordeneu pel nom. Ex_73 Traure tota la informaci\u00f3 (amb l'import) de la factura m\u00e9s cara. Ha de ser per mig de subconsultes. Mireu que segurament hi haur\u00e0 2 subconsultes. En la m\u00e9s interna calculem l'import de les factures. En l'altra calculem el m\u00e0xim. I en la consulta principal, busquem la factura que coincideix amb aquest m\u00e0xim. Ex_74 (voluntari) Obtenir el venedor que ha venut m\u00e9s unitats de cada categoria, sense considerar en la categoria el valor nul. Aquesta consulta la podr\u00edem considerar ja com molt avan\u00e7ada. Ex_75 Traure el nom de tots els clients i venedors implicats en alguna venda del primer trimestre de 2015. Intentar traure en una segona columna el text Venedor per als venedors, i Client per als clients. Ordenat pel nom. Ex_76a Traure per mig de sent\u00e8ncies d'operacions de conjunts els pobles on tenim algun venedor o algun client. No volem resultats repetits, i ho volem ordenat pel nom del poble. Un total de 31 files Ex_76b Modificar l'anterior per a traure els pobles on tenim al mateix temps venedors i clients Ex_76c Modificar l'anterior per a traure els pobles on tenim venedors per\u00f2 no tenim clients Llicenciat sota la Llic\u00e8ncia Creative Commons Reconeixement NoComercial SenseObraDerivada 2.5","title":"Exercicis amb els resultats (part II)"}]}